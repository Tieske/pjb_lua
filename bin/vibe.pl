#! /usr/bin/perl
#########################################################################
#        This Perl script is Copyright (c) 2013, Peter J Billam         #
#                          www.pjb.com.au                               #
#                                                                       #
#     This script is free software; you can redistribute it and/or      #
#            modify it under the same terms as Perl itself.             #
#########################################################################
#
# 20130412  The aim is to behave like vim -c 'set lines=2' (or perhaps 4?)
# except to not use curses-code, so as to be in control of which
# characters would be output to the screen, and in what order;
#   and to use this control to achieve the same optimal speech interface,
#   under both speakup and yasr.
# I store the command-string already parsed into
#   multiplier,cmd,position etc, to ease the work that '.' has to do
# Vi doesn't allow '.' on ':' ed-commands, but I've always thought it should
# Wrap when inserting is perhaps desirable for a visually-impaired user;
#   but python suffers, and long lines can always be generated by J
# 20200508 TODO: # finds previous occurence of word under cursor
# 20200508 TODO: fX and FX go forward or backward to X in the current line
# 20200509 TODO: ; repeats previous f or F seek and , in the other direction
#   fix long lines in insert mode
#   . should repeat the last insert, including the text inserted :-)


my $Version       = '2.4'; # f F ; and , now work
my $VersionDate   = '10may2020';
use open ':locale';
eval 'require Term::ReadKey';
if ($@) { die "you need to install Term::ReadKey from www.cpan.org\n"; }
eval 'require Term::ReadLine';
if ($@) { die "you need to install Term::ReadLine::Gnu from www.cpan.org\n"; }

my $MinusC   = ''; # the -c argument. but it should be a list of commands ...
my $ReadOnly = 0;  # 2.0

while ($ARGV[$[] =~ /^-([a-zR])/) {
	if ($1 eq 'v')      { shift;
		my $n = $0; $n =~ s{^.*/([^/]+)$}{$1};
		print "$n version $Version $VersionDate\n";
		exit 0;
	} elsif ($1 eq 'c') { shift; $MinusC = shift;
	} elsif ($1 eq 'R') { shift; $ReadOnly = 1;
	} else {
		print "usage:\n";  my $synopsis = 0;
		while (<DATA>) {
			if (/^=head1 SYNOPSIS/)     { $synopsis = 1; next; }
			if ($synopsis && /^=head1/) { last; }
			if ($synopsis && /\S/)      { s/^\s*/   /; print $_; next; }
		}
		exit 0;
	}
}

my  ($Cols, $Rows,$Xpix,$Ypix) = Term::ReadKey::GetTerminalSize();
$SIG{'WINCH'} = sub {
	($Cols, $Rows,$Xpix,$Ypix) = Term::ReadKey::GetTerminalSize();
};
my $FileName       = '';
my @Lines          = ();
my $LineNum        = $[;
my $CharNum        = $[;
my $LastMessage    = '';   # used by sub message
my $LastDisplay    = '';   # used by sub display_line
my $FileIsChanged  = 0;
my $FileLastSaved  = time;
my %Opt = ();
  $Opt{'reader'}  = $ENV{'VIBE_READER'} or 'yasr';
  $Opt{'keyecho'} = $ENV{'VIBE_KEYECHO'} || 0;
  $Opt{'tabstop'} = 4;
  $Opt{'wrap'}    = 1;
consult_vimrc();           # consult ~/.vimrc to reset %Opt if necessary
my $DisplayLine    = 0;
my @Buffer         = ();   #  array of lines
my $BufferIsWholeLine = 0; #  1 is yy, y}, .,$d   0 is d3w y$   etc
my $LinesPerPage   = 20;   # for KEY_NPAGE and KEY_PPAGE
my $FindString     = '';
my $FindForwards   = 1;    # / or ? == +1 or -1
my $SeekForwards   = 1;    # f or F == +1 or -1
my $LastSeekChar   = undef;
my %ForceWholeLine = map { $_, 1 } qw($ } {);   # c and d want the whole line
my @HistoryGoBack    = (); # list of patches, see Text::Diff and Text::Patch
my @HistoryGoForward = (); # list of patches, see Text::Diff and Text::Patch
my @HistoryLineNums  = (); # list of LineNums
my @HistoryCharNums  = (); # list of CharNums
my $Ihistory         = -1;
my $InsertMode       = 0;
my %Mark2LineNum     = ();
my %Mark2CharNum     = ();
my %Prompt2Name = (
	'/'=>'vibe_find', '?'=>'vibe_find', '!'=>'vibe_pipe', ':'=>'vibe_cmd',
);
my %StoreLastChange = (); # perform_a_change remembers multiplier,range,cmd...
my $LastWasUpOrDown = 0;   # 20150905 1.9
my $LastWasLineNum  = 0;   # 20150910 2.0
my $TmpFile         = "/tmp/vibe.$$";
my ($Smir, $Rmir, $Dch1) = get_smir_rmir_dch1();   # for use in insert_mode
my $HOME = $ENV{'HOME'} || $ENV{'LOGDIR'} || (getpwuid($<))[7];
my $Icol = 0;
my $Irow = 0;

# pinched from Term::Clui
$A_NORMAL    =  0;
$A_BOLD      =  1;
$A_UNDERLINE =  2;
$A_REVERSE   =  4;
$KEY_UP    = 0403;
$KEY_LEFT  = 0404;
$KEY_RIGHT = 0405;
$KEY_DOWN  = 0402;
$KEY_ENTER = "\r";
$KEY_INSERT = 0525;
$KEY_DELETE = 0524;
$KEY_HOME   = 0523;
$KEY_END    = 0522;
$KEY_PPAGE  = 0521;
$KEY_NPAGE  = 0520;
$KEY_BTAB   = 0541;
initscr();
gotoxy(0,$DisplayLine+2);
sub END { print "\r\n"; endwin(); }

my $n_files = scalar @ARGV;
if ($n_files > 1) { message("$n_files files to edit"); sleep 1; }
while (@ARGV) {
	$FileName = shift @ARGV;
	$FileLastSaved = time;
	$LineNum = 0+get_default($FileName) || $[;
	my $msg = "line ".($LineNum+1-$[);
	if (-d $FileName)  {
		if (@ARGV) {
			message("$FileName is a directory, skipping"); sleep 2; next;
		} else {
			up(2); warn("sorry, $FileName is a directory\n"); up(1);
			exit;
		}
	}
	if (! -e $FileName) {
		$msg = " new file";
		if (! open(F, '>', $FileName)) {
			warn "can't create $FileName: $!\r\n"; next;
		}
		# print F "\n";  close F;   # not so fast...  q! should leave no file
		unlink $FileName;
	} else {
		if (!-w $FileName) { $msg = " warning: editing a read-only file"; }
		if (! open(F, '<', $FileName)) {
			warn "can't open $FileName: $!\r\n"; next;
		}
		@Lines = <F>;   close F;
	}
	if (! @Lines) { @Lines = ("\n"); }
	chomp @Lines;
	constrain_line_num();
	$FileIsChanged = 0;
#puts("this should be spoken");
#puts_silent("this should be silent");  # but isn't :-(
	# Modes: command, insert, replace, colon, find
	if ($MinusC) { colon_mode($MinusC); }   # should be a list
	message($msg);
	command_mode();  # every other mode returns to command_mode
}
exit 1;  # the normal exit is through colon_mode

sub word_under_cursor { # is this the Perl way to seek the whole word ?
	my $line = $Lines[$LineNum];
	my $this   = substr $line, $CharNum, 1;
	if (! ($this =~ /\w/)) { return undef; }
	my $before = substr $line, $[, $CharNum;
	my $after  = substr $line, $CharNum+1;
	$before =~ m/(\w*)$/; $before = $1;
	$after  =~ m/^(\w*)/; $after  = $1;
	return $before.$this.$after;
}
sub seek_in_line { my ($delta, $c) = @_;  # used by f F ; ,
	my $line = $Lines[$LineNum];
	my $seekchar;
	if (defined($c)) { $seekchar=$c ; $LastSeekChar=$c ;
	} else           { $seekchar=$LastSeekChar;
	}
	if (! defined($seekchar)) { message('no previous seek') ; return; }
	my $char_num = $CharNum + $delta;
	while ($char_num >= $[ and $char_num <= length($line)) {
		my $c = substr $line, $char_num, 1;
		if ($c eq $seekchar) { $CharNum = $char_num; last; }
		$char_num = $char_num + $delta;
		# if ($char_num < $[) { last; }
	}
	message(sprintf("character %d", $CharNum+1-$[));
	return;
}

sub command_mode {
	# command_mode handles (\d+) h j k l u ^R m ' ~ x r b w p d.* c.*
	#  and after  : / ? i I o O  it invokes another mode.
	# we separate insert_mode, replace_mode from here
	# in command, insert and replace modes we are at a particular
	#  LineNum and CharNum, and can move around with the arrow-keys
	# therefore these movements are handled by sub movement
	my $multiplier = 0;
	display_line();
	while (1) {   # the main LOOP
		$c = getch();
		if ($c =~ /^\d$/) {
			if ($multiplier == 0 and $c eq '0') {   # BOL
				$CharNum = $[; display_line(); next;
			}
			$multiplier = 10*$multiplier + $c;
			next;
# XXX this conflicts with ',' meaning seek_in_line in the other direction
#		} elsif ($c eq ',') { next;  # specifies ranges, eg:  .,$d  2,30y
		}
		if ($multiplier < 1) { $multiplier = 1; }
		$LastWasUpOrDown = 0;
		if ($c eq '/' or $c eq '?') { find_dialogue($c);
		} elsif ($c eq 'n' or $c eq 'N'
		  or $c eq 'w' or $c eq 'b' or $c eq 'e') {  # with multiplier
			my ($line_num, $char_num) = find_position($multiplier.$c);
			if (defined $char_num) {
				$LineNum = $line_num; $CharNum = $char_num;
				message();
				display_line();
			} else { message("not found");
			}
		} elsif ($c eq ':') {
			if ('next' eq colon_mode()) { return 'next'; }
			$CharNum = $[;
			display_line();
		} elsif ($c eq '#') {
			my $word = word_under_cursor();
			if ($word) {
				$FindString     = $word;
				$FindForwards   = -1;
				my ($line_num, $char_num) = find_position('n');
				if (defined $char_num) {
					$LineNum = $line_num; $CharNum = $char_num;
					$LastWasUpOrDown = 0;
					message();
					display_line();
				} else { message("$find_string not found");
				}
			} else {
				message("no word under cursor");
			}
		} elsif ($c eq 'f') {
			$SeekForwards = 1;  seek_in_line( 1, getch());
			display_line();
		} elsif ($c eq 'F') {
			$SeekForwards = -1; seek_in_line(-1, getch());
			display_line();
		} elsif ($c eq ';') {
			seek_in_line($SeekForwards);
			display_line();
		} elsif ($c eq ',') {
			seek_in_line(-1*$SeekForwards);
			display_line();
		} elsif ($c eq 'g' || $c == $KEY_HOME) {
			$LineNum = $[;  $CharNum = $[;
			message(); display_line();
		} elsif ($c eq 'G' || $c == $KEY_END) {
			$LineNum = $#Lines;  $CharNum = $[ - 1 + length $Lines[$LineNum];
			constrain_char_num();
			message(); display_line();
		} elsif ($c == $KEY_LEFT || $c eq 'h' || $c eq "\cH" || $c eq "\x7f"){
			if ($CharNum <= $[) { message("already at B O L"); $CharNum = $[;
			} else {
				$CharNum -= $multiplier;
				if ($CharNum < $[) { $CharNum = $[; }
				message();  display_line();
			}
		} elsif ($c == $KEY_DOWN || $c eq 'j' || $c eq "\r") {
			if ($LineNum >= $#Lines) { message("already at E O F"); next; }
			$LineNum += $multiplier;
			constrain_line_num();
			if ($c eq "\r") { $CharNum = $[; }
			my $l = $[ - 1 + length $Lines[$LineNum]; # ARGHH can be -1 !!
			if (($l >= $[) and ($CharNum > $l)) { $CharNum = $l; }
			$LastWasUpOrDown = 1;
			message();  display_line();
		} elsif ($c == $KEY_UP || $c eq 'k') {
			if ($LineNum <= $[) { message("already at B O F"); next; }
			$LineNum -= $multiplier;
			if ($LineNum < $[) { $LineNum = $[; }
			my $l = $[ - 1 + length $Lines[$LineNum];
			if (($l >= $[) and ($CharNum > $l)) { $CharNum = $l; }
			$LastWasUpOrDown = 1;
			message(); display_line();
		} elsif ($c == $KEY_RIGHT || $c eq 'l') {
			my $l = $[ - 1 + length $Lines[$LineNum];
			if ($CharNum >= $l) { message("already at E O L");
			} else {
				$CharNum += $multiplier;
				my $l = length $Lines[$LineNum];
				if ($CharNum > $l) { $CharNum = $l; }
				message();  display_line();
			}
		} elsif ($c eq '$') {   # to end of line
			$CharNum = $[ - 1 + length $Lines[$LineNum];
			display_line();
		} elsif ($c == $KEY_NPAGE) {
			$LineNum += $LinesPerPage;   constrain_line_num();
			if ($CharNum > ($[ - 1 + length $Lines[$LineNum])) {
				$CharNum = $[ - 1 + length $Lines[$LineNum];
				constrain_char_num();
			}
			message(); display_line();
		} elsif ($c == $KEY_PPAGE) {
			$LineNum -= $LinesPerPage;   constrain_line_num();
			if ($CharNum > ($[ - 1 + length $Lines[$LineNum])) {
				$CharNum = $[ - 1 + length $Lines[$LineNum];
				constrain_char_num();
			}
			message(); display_line();
		} elsif ($c eq '~' or $c eq 'x' or $c == $KEY_DELETE
		  or $c eq 'J' or $c eq '.' or $c eq 'p' or $c eq 'P' or $c eq 'R'
		  or $c eq 'i' or $c eq 'I' or $c eq 'o' or $c eq 'O' or $c eq 'a') {
			perform_a_change(mult=>$multiplier, cmd=>$c);
		} elsif ($c eq 'C' or $c eq 'D' or $c eq 'A') {
			perform_a_change(cmd=>$c);
		} elsif ($c eq '=') {
			my $s = sprintf("line %d out of %d, char %d, file ",
			  $LineNum+1,  scalar @Lines,  $CharNum+1,);
			if ($FileIsChanged) { $s.='is changed'; } else { $s.='unchanged'; }
			message($s);
		} elsif ($c eq 'r') {  # replace one char
			my $c2 = getch();   if ($c2 eq "\e") { next; }
			perform_a_change(mult=>$multiplier, cmd=>$c, text=>$c2);
		} elsif ($c eq 'c' or $c eq 'd' or $c eq 'y') { 
			my $pos = endpos_dialogue($c);  # passes $c to detect dd
			perform_a_change(mult=>$multiplier, cmd=>$c, pos=>$pos);
		} elsif ($c eq '!') {
			my $c2 = getch();   if ($c2 eq "\e") { next; }
			# must loop to collect a possible sub-multiplier, eg: !5}
			my $shellcmd = read_line('!');
			if (! $shellcmd) { next; }
			perform_a_change(mult=>$multiplier, cmd=>$c,
			  pos=>$c2, shellcmd=>$shellcmd);
		} elsif ($c eq 'Y') {   # same as yy
			perform_a_change(mult=>$multiplier, cmd=>'y', pos='y');
		} elsif ($c eq 'Z') {
			my $c2 = getch();  if ($c2 eq 'Z') {
				save_dialogue(undef,'quitting'); quit_dialogue();
			}
		} elsif ($c eq 'm') {  # set mark
			my $c2 = getch();  if ($c2 =~ /[a-zA-Z]/) {
				$Mark2LineNum{$c2} = $LineNum;
				$Mark2CharNum{$c2} = $CharNum;
				message("mark $c2 set");
			}
		} elsif ($c eq q{'}) {  # goto a mark
			my $c2 = getch();  if ($c2 =~ /[a-zA-Z]/) {
				goto_position("'$c2", "mark $c2 not set");
			}
		} elsif ($c eq '{' or $c eq '}') {  # previous or next paragraph
			goto_position("$multiplier$c", "no more paragraphs");
		} elsif ($c eq 'u')    { un_do();
		} elsif ($c eq "\022") { re_do();
		} elsif ($c eq "\e")   { next; # should flash
		}
		$multiplier = 0;
	}
}

sub colon_mode { my $arg = shift;   # to handle the vibe -c arg
	# colon_mode handles r w q (\d+) and /^$/,$-5 s/\t/    /g
	#  does filename-completion as necessary,
	#  and expects a \n to terminate the command.
	# Term::ReadLine::Gnu does tab-completion for filenames by default...
	my $line_num = 0;
	my $cmdstr = $arg || read_line(':');
	$LastMessage = ":$cmdstr";
	gotoxy(0,$DisplayLine+1);
	if (is_position($cmdstr)) { goto_position($cmdstr, "not found"); return; }
	my ($range, $cmd, $arg) = ($cmdstr =~ /([.\d]+,[.\d\$]+)?(\S+)\s*(.*)$/);
	if      ($cmd eq 'q')  { quit_dialogue(); return;
	} elsif ($cmd eq 'q!') { undef @ARGV;  exit 0;
	} elsif ($cmd eq 'w')  { save_dialogue($arg); return;
	} elsif ($cmd eq 'wq') { save_dialogue(undef,'quitting'); quit_dialogue();
		return;
	} elsif ($cmd eq 'wq!'){ save_dialogue(); undef @ARGV; exit 0;
	} elsif ($cmd eq 'n')  { save_dialogue(); return 'next';
	} elsif ($cmd eq 'wn') { save_dialogue(); return 'next'; # if write fails?
	} elsif ($cmd eq 'r')  { read_dialogue($arg); return;
	# 20150905 also delete and yank ?  see eg: delete_between()
	} elsif ($cmd eq 'd' or $cmd eq 'y')  {   # 20200506 added 'y'
		my ($line1,$line2) = split(/,/,$range,2);
		my ($staline, $stachar) = find_position($line1);
		my ($endline, $endchar) = find_position($line2);
		if ($cmd eq 'd') {
			delete_between($staline,0,$endline,0); # also .+4 $-2  +3 -17 etc
		}
		$BufferIsWholeLine = 1;
		return;
	} elsif ($cmd =~ /^\d+/) {  # also .+4 $-2 etc... +3 -17 etc...
		$LineNum = 0 + $cmd - 1 + $[;  constrain_line_num();
		constrain_char_num();
		message(); display_line(); return;
	} elsif ($cmd eq '$') {
		$LineNum = $#Lines;
		constrain_char_num();
		message(); display_line(); return;
	}
}

sub display_line {
	# Handle long lines by just displaying $Cols-1 of them at once, and
	# h l Left Right w b 0 $ still work as expected; still some BUGS here..
	# printing a char to the right column sends the cursor to the next line :-)
	# gotoxy(0,$DisplayLine);
	my $s = expand_tabs();
	my $colnum = charnum2colnum($CharNum);
	# test if the line is too long to fit
	if (length($s) > $Cols) {
		my $new_colnum = round(($Cols-1) * $colnum / length($s));
		my $shave_off_start = $colnum - $new_colnum;
		if ($shave_off_start > 0) {
			substr $s, $[, $shave_off_start, '';
			$colnum = $new_colnum;
		}
		if (length($s) >= $Cols)   { substr($s, $[+$Cols-1) = ''; }
	}
	# test if the line is unchanged, and if so not redisplay it,
	# except that in InsertMode, LastDisplay will be out of date
	if ($InsertMode || ($s ne $LastDisplay)) {
		puts_xy_clr(0, $DisplayLine, $s); $LastDisplay=$s;
	}
	gotoxy($colnum, $DisplayLine);
}

sub charnum2colnum {  my $charnum = shift;  # closely related to expand_tabs
    if ($charnum < $[) { $charnum = $[; }
    my $colnum = 0;
    my @chars = split(//, $Lines[$LineNum]);
	if ($InsertMode) {
    	if ($charnum > ($#chars+1)) { $charnum = $#chars+1; }
	} else {
    	if ($charnum > $#chars) { $charnum = $#chars; }
	}
    foreach my $i (0.. $charnum) {   # for all the previous chars
        if ($chars[$i] eq "\t") {  # depends on $[=0
            $colnum = -1 + $Opt{'tabstop'}
			  * (1 + int(($colnum+2)/$Opt{'tabstop'}));
        } else {
            $colnum += 1;
        }
    }
	return $colnum-1+$[;
}
sub expand_tabs {   # closely related to charnum2colnum
	my @expanded = ();
    my $colnum = 0;
	foreach my $c (split(//, $Lines[$LineNum])) {
		if ($c eq "\t") {
			my $old_colnum  = $colnum;
            $colnum = -1 + $Opt{'tabstop'}
			  * (1 + int(($colnum+1)/$Opt{'tabstop'}));
			push @expanded, ' ' x ($colnum-$old_colnum);
		} else {
            $colnum += 1;
			push @expanded, $c;
		}
	}
	return join('',@expanded);
}

sub perform_a_change {  my %arg = @_;
	# called by the main LOOP whenever it wants to modify the file
	# And perhaps also by colon_mode eg:  !!   !}   .,$s/old/new/g
	#   mult, eg: the 2 in 2dd
	#   range1, range2, eg: . or $ or $-5
	#   cmd,  eg: c or d or i or ! or !!
	#   pos,  eg: $ or .-6 or 2}
	#   text, eg: inserted text
	#   shellcmd, eg: fmt or 8vab
	if (! $arg{'cmd'}) { die "BUG: perform_a_change called without arg{cmd}"; }
	if ($arg{'cmd'} ne '.') {
		%StoreLastChange = %arg;
	} else {
		if (!%StoreLastChange) {
			message("no previous command to repeat"); return 0;
		}
		my $tmp = $arg{'mult'};
		%arg = %StoreLastChange;
		# $arg{'mult'} = $tmp; only if $tmp exists, I think 16x  .
	}
	add_to_history();
	$FileIsChanged = 1;
	if (! $arg{'mult'}) { $arg{'mult'} = 1; }
	if ($arg{'cmd'} eq '~') {   # all these cases started life in the LOOP
		my @chars = substr($Lines[$LineNum], $CharNum, $arg{'mult'});
		foreach (@chars) {
			if (/[a-z]/) { $_ = uc; } elsif (/[A-Z]/) { $_ = lc; }
		}
		substr($Lines[$LineNum], $CharNum, $arg{'mult'}) = join('',@chars);
		$CharNum += $arg{'mult'};
		my $l = length $Lines[$LineNum];
		if ($CharNum > $l) { $CharNum = $l; }
	} elsif ($arg{'cmd'} eq 'J') {
		# 20160811 it would be nice if J only spoke the remainder of the line
		my $tmp = $Lines[$LineNum];  $tmp =~ s/\s*$//;
		foreach (1..$arg{'mult'}) {  # but vi sees 2J as meaning join 2 lines!
			my $next = splice(@Lines,$LineNum+1,1);
			$next =~ s/^\s*/ /;
			$CharNum = length($tmp) + $[;
			$tmp .= $next;
		}
		$Lines[$LineNum] = $tmp;
	} elsif ($arg{'cmd'} eq 'x' or $arg{'cmd'} == $KEY_DELETE) {
		$BufferIsWholeLine = 0;
		@Buffer = ( substr($Lines[$LineNum], $CharNum, $arg{'mult'}) );
		substr($Lines[$LineNum], $CharNum, $arg{'mult'}) = '';
		constrain_char_num();
	} elsif ($arg{'cmd'} eq 'p' or $arg{'cmd'} eq 'P') {
		# There are whole-line Buffers (yy, Y) and within-the-line Buffers
		#  (dw, d9w, d$)  (which can also include several lines!, eg d9w)
		if ($BufferIsWholeLine) {
# XXX BUG this does not get invoked for d} or y} or :.,$y etc
			$CharNum = $[;
			if ($arg{'cmd'} eq 'p') {
				if ($LineNum == $#Lines) { push @Lines, @Buffer;
				} else { splice(@Lines, $LineNum+1, 0, @Buffer);
				}
				$LineNum += 1;   message();
			} else {   # 'P'
				splice(@Lines, $LineNum, 0, @Buffer);
			}
		} else {   # it's a within-the-line Buffer
			if ($arg{'cmd'} eq 'p') { $CharNum += 1; }
			# BUG this handles only within-the-line Buffers containing no \n
			substr($Lines[$LineNum], $CharNum, 0) = $Buffer[$[] x $arg{'mult'};
		}
	} elsif ($arg{'cmd'} eq 'r') {
		substr($Lines[$LineNum], $CharNum, $arg{'mult'})
		  = $arg{'text'} x $arg{'mult'};
		$CharNum += $arg{'mult'}; constrain_char_num();
	} elsif ($arg{'cmd'} eq 'R') {   # 2.1 Replace successive chars
		message(' REPLACE');
		insert_mode($arg{'text'}, 'R');
	} elsif ($arg{'cmd'} eq 'c') {
		if ($arg{'pos'} eq 'c') {  # special-cased ergonomic change-this-line
			splice(@Lines, $LineNum, $arg{'mult'}, '');
			constrain_line_num();
			$CharNum = $[;
		} else {  # invoke find_position and delete to there
			if ($ForceWholeLine{$arg{'pos'}}){ $CharNum = $[; }
			my ($end_line, $endchar) = find_position($arg{'pos'});
			if (defined $end_line) {
				if ($end_line == $#Lines) { $endchar = $endchar+1; }
				delete_between($LineNum, $CharNum, $end_line, $endchar);
				message("line ".($LineNum+1-$[).' INSERT');
				insert_mode($arg{'text'});
			} else {
				message("can't find $arg{'pos'}");
			}
		}
	} elsif ($arg{'cmd'} eq 'd') {  # special-cased ergonomic delete-this-line
		if ($arg{'pos'} eq 'd' or $arg{'pos'} eq '$') {   # 20200507
# XXX not quite ... d$ should leave the empty line,
#               but dd should delete the whole line
			#if ($pos ne '}') {
			$BufferIsWholeLine = 1;
			#}
			@Buffer = splice(@Lines, $LineNum, $arg{'mult'});
			constrain_line_num();
			$CharNum = $[;
		} else {  # invoke find_position and delete to there
			my ($end_line, $endchar) = find_position($arg{'pos'});
			if (defined $end_line) {
				if ($end_line == $#Lines) { $endchar = $endchar+1; }
				delete_between($LineNum, $CharNum, $end_line, $endchar);
			} else {
				message("can't find $arg{'pos'}");
			}
		}
	} elsif ($arg{'cmd'} eq 'y') {
		if ($arg{'pos'} eq 'y') {  # special-cased ergonomic yank-this-line
			$BufferIsWholeLine = 1;
			@Buffer = @Lines[$LineNum..($LineNum+$arg{'mult'}-1)];
			if ($arg{'mult'} > 1) { message("$arg{'mult'} lines yanked"); }
		} else {  # invoke find_position and yank to there
			my ($end_line, $endchar) = find_position($arg{'pos'});
			if (defined $end_line) {
				if ($end_line == $#Lines) { $endchar = $endchar+1; }
# NO ! BUG ! yank, not delete !
				delete_between($LineNum, $CharNum, $end_line, $endchar);
			} else {
				message("can't find $arg{'pos'}");
			}
		}
	} elsif ($arg{'cmd'} eq '!') {
		if ($arg{'pos'} eq '!') {
			if (! open(T, '>', $TmpFile)) {
				message("can't create $TmpFile: $!"); next;
			}
			print T $Lines[$LineNum],"\n";   close T;
			if (! open(P, '-|', "$arg{'shellcmd'} < $TmpFile")) {
				message("can't run $arg{'shellcmd'}: $!"); next;
			}
			my @answer = <P>;   close P;   unlink $TmpFile;
			chomp @answer;
			splice(@Lines, $LineNum, 1, @answer);
		} else {
			if ($ForceWholeLine{$arg{'pos'}}){ $CharNum = $[; }
			my ($end_line, $endchar) = find_position($arg{'pos'});
			if (defined $end_line) {
				if (! open(T, '>', $TmpFile)) {
					message("can't create $TmpFile: $!"); next;
				}
				if (! open(P, '-|', "$arg{'shellcmd'} < $TmpFile")) {
					message("can't run $arg{'shellcmd'}: $!"); next;
				}
				if ($end_line == $#Lines) { $endchar = $endchar+1; }
				my $txt = delete_between($LineNum,$CharNum,$end_line,$endchar);
				print T $txt,"\n";   close T;
				my @answer = <P>;   close P;   unlink $TmpFile;
				chomp @answer;
				splice(@Lines, $LineNum, 0, @answer);
			} else {
				message("can't find $arg{'pos'}");
			}
		}
	} elsif ($arg{'cmd'} eq 'i') { # 20150905
		message("line ".($LineNum+1-$[).' INSERT');  insert_mode($arg{'text'});
	} elsif ($arg{'cmd'} eq 'I') {
		$CharNum=$[; display_line();
		message("line ".($LineNum+1-$[).' INSERT');  insert_mode($arg{'text'});
	} elsif ($arg{'cmd'} eq 'a') {
		$CharNum += 1; display_line();  # handle already-at-EOL specially..
		if ($CharNum > ($[ -1 + length $Lines[$LineNum])) { right(1);
		} else {  message("line ".($LineNum+1-$[).' INSERT');
		}
		insert_mode($arg{'text'});
	} elsif ($arg{'cmd'} eq 'A') {
		$CharNum = $[ + length $Lines[$LineNum];
		display_line(); right(1);
		insert_mode($arg{'text'});   # mustn't call message if after EOL
	} elsif ($arg{'cmd'} eq 'C') {
		$Lines[$LineNum] = substr($Lines[$LineNum], $[, $CharNum);
		clrtoeol(); insert_mode($arg{'text'});   # no message if after EOL
	} elsif ($arg{'cmd'} eq 'D') {
		$BufferIsWholeLine = 0;
		my @s = split '', $Lines[$LineNum];
		@Buffer = ( substr($Lines[$LineNum], $CharNum, $#s-$CharNum+1, '') );
	} elsif ($arg{'cmd'} eq 'O') {   # open a new line above
		$CharNum= $[;
		splice(@Lines, $LineNum, 0, '');   display_line();
		message("line ".($LineNum+1-$[).' INSERT');
		insert_mode($arg{'text'});
	} elsif ($arg{'cmd'} eq 'o') {   # open a new line below
		$LineNum += 1; $CharNum= $[;
		splice(@Lines, $LineNum, 0, '');   display_line();
		message("line ".($LineNum+1-$[).' INSERT');
		insert_mode($arg{'text'});
	}
	display_line();
}

sub constrain_char_num {
	# the problem is that if the line has one char, then $CharNum = $[
	# but if the line is empty, then $CharNum=-1 causes all substr to crash
	if ($CharNum <= $[) { $CharNum = $[; return; }
	# in Append mode, CharNum can be one beyond the EOL...
	my $max = $[ -1 + length $Lines[$LineNum];
	if ($CharNum > $max) { $CharNum = $max; }
	return;
}
sub constrain_line_num {
	if ($LineNum <= $[) { $LineNum = $[; return; }
	if ($LineNum > $#Lines) { $LineNum = $#Lines; }
	return;
}

sub endpos_dialogue { my $cmd = shift;   # eg: 'c' or 'd' or '!'
	# the $pos (eg: d5w) ends on } w b e ^ $ '[a-z] /astring\n ?astr\n
	# /astring/+4   many,many possibilities... (also from c,!,y)
	my @pos = ();
	while (1) {
		my $c = getch();   if ($c eq "\e") { return undef; }
		if ($c eq 'w' or $c eq 'b' or $c eq 'e' or $c eq '}' or $c eq '{'
		 or $c eq '^' or $c eq '$' or $c eq $cmd) { push @pos, $c;  last; }
# XXX must handle d$ as delete-to-EOL (not to delete-to-last-line) !
#     likewise y$ and c$ and !$
#     in other words '$' AS THE FIRST GETCH() must be special-cased
		if ($c =~ /\d/) { push @pos, $c;  next; }
		if ($c eq q{'}) {
			push @pos, q{'};
			my $c = getch();
			if ($c eq "\e") { return undef;
			} elsif ($c =~ /[a-z]/) { push @pos, $c;  last;
			} else { message("strange mark '$c");  return undef;
			}
		}
		if ($c eq '/' or $c eq '?') { push @pos, $c, read_line($c); }
		message("strange position $c");
	}
	# my $p = join '',@pos; debug("p=$p");
	return join '',@pos;
}

sub find_dialogue { my $c = shift;   # no multipliers here, please
	# need to separate finding from pre-dialogue and post-display. So:
	if      ($c eq '/') { $FindForwards   = 1;  $find_forwards = 1;
	} elsif ($c eq '?') { $FindForwards   = -1; $find_forwards = -1;
	} else { message("BUG: find_dialogue called with c=$c"); return;
	}
	my $find_string = read_line($c);
	if ($find_string eq '') { display_line(); return; }
	eval '"abcd" =~ /$find_string/;';
	if ($@) {  # avoid dieing on RE syntax errors
		my $s = $@;
		$s =~ s/at\s\(eval .*$//;
		$s =~ s/marked by.*HERE in //;
		message ($s);
		return;
	}
	$FindString = $find_string;
	my ($line_num, $char_num) = find_position('n');
	if (defined $char_num) {
		$LineNum = $line_num; $CharNum = $char_num;
		$LastWasUpOrDown = 0;
		message();
		display_line();
	} else { message("$find_string not found");
	}
}

sub read_line { my $prompt = shift;
	gotoxy(0,$DisplayLine+1); clrtoeol();
	endwin();
	my $name = $Prompt2Name{$prompt} || 'vibe_misc';
	my $term = new Term::ReadLine($name);
	my $attribs = $term->Attribs;
	if ($name eq 'vibe_find') {
		$attribs->{completion_entry_function}
		  = $attribs->{list_completion_function};
		$attribs->{completion_word} = ();  
	}
   	my $cmdstr = $term->readline($prompt);
	$cmdstr =~ s/ $//;
	initscr();
	print TTY "\e[A"; $Irow = $DisplayLine + 1; clrtoeol();
	# $Irow=$DisplayLine+2; gotoxy(0,$DisplayLine+1); $LastWasUpOrDown=1;
	return $cmdstr;
}

sub is_position { my $arg = shift;
	if ($arg =~/^\d+$/ or $arg =~ /^\.([-+]\d+)?$/) { return 1; }
	if ($arg =~/^'[a-z]$/ or $arg =~ /^\$(-\d+)?$/) { return 1; }
	# needs expanding to recognise everything that find_position can handle
	return 0;
}

sub goto_position { my ($cmdstr, $msg) = @_;
	my ($line_num, $char_num) = find_position($cmdstr);
	if (defined $line_num) {
		$LineNum = $line_num; $CharNum = $char_num;
		message();  display_line();
	} else {
		message($msg || "$cmdstr not found");
	}
}

sub find_position { my $arg = shift;
	# handling 123, and (\d*)?[.}^$nNwbe]([-+]\d+)?
	# and returning ($line_num,$char_num) could then be used in d4w or
	# in  .,}+4w /tmp/t  by being invoked twice by a general  sub range
	# in vi, [nN] _is_ useable in a range, also in dn or d3n etc.
	# handle also marks, eg: 'a
	my $line_offset = 0;
	if ($arg =~ s/([-+]\d+)$//) { $line_offset = 0 + $1; }
	if ($arg eq '.') {   # 1.3
		my $n = $LineNum + $line_offset;
		if ($n > $#Lines) { $n = $#Lines; } elsif ($n < $[) { $n = $[; }
		return ($n, $[);
	} elsif ($arg eq '$') {   # 1.3
		my $n = $#Lines + $line_offset;
		if ($n > $#Lines) { $n = $#Lines; } elsif ($n < $[) { $n = $[; }
		return ($n, $[);
	} elsif ($arg =~ /^\d+$/) {   # 1.3
		my $n = $[ - 1 + $arg + $line_offset;
		if ($n > $#Lines) { $n = $#Lines; } elsif ($n < $[) { $n = $[; }
		return ($n, $[);
	} elsif ($arg =~ /^'([a-zA-Z])$/) {   # 1.3  
		my $mark = $1;
		if (defined $Mark2LineNum{$mark}) {
			return ($Mark2LineNum{$mark}, $Mark2CharNum{$mark}||$[);
		} else {
			message("Mark $mark not set"); return ();
		}
	}
	# the remaining possibilities can take multipliers...
	$arg =~ /^(\d*)(.)$/;
	my $multiplier = $1 || 1; my $c = $2;
	my $find_direction    = 1;
	my $find_string   = $FindString;
	my $find_forwards = $FindForwards;
	if      ($c eq 'n') { $find_direction = 1;    # next
	} elsif ($c eq 'N') { $find_direction = -1;   # previous
	} elsif ($c eq 'w') { $find_forwards  = 1;  $find_string = '(?<=\W)\w';
	} elsif ($c eq 'b') { $find_forwards  = -1; $find_string = '\b\w';
	} elsif ($c eq 'e') { $find_forwards  = 1;  $find_string = '(?<=\w)\b';
	} elsif ($c eq '}') { $find_forwards  = 1;  $find_string = '^\s*$'; #XXX
	} elsif ($c eq '{') { $find_forwards  = -1; $find_string = '^\s*$'; #XXX
	} else { message("BUG: find_position called with c=$c"); return;
	}
	my $line_num = $LineNum;
	my $char_num = $CharNum;

	foreach (1..$multiplier) {
		my $found_single   = 0;
		# first find from CharNum on the current line, unless { or }
		if ($c ne '{' and $c ne '}') {
			if ($find_forwards > 0) {
				my $remainder = substr $Lines[$LineNum], $char_num+1;
				if ($remainder =~ /$find_string/) {
					$char_num += 1 + length $`;
					$found_single = 1; next;
				}
			} else {
				my $previous = substr $Lines[$LineNum], $[, $char_num;
				if ($previous =~ /(.*)$find_string/) {   # find the LAST match
					$char_num =  length $1;
					$found_single = 1; next;
				}
			}
		}
		# if not, look through the subsequent lines
		if      ($c eq 'w') { $find_string = '\b\w';
		} elsif ($c eq 'b') { $find_string = '(.*)\b\w';
		} elsif ($c eq 'e') { $find_string = '(?<=\w)\b';
		}
		$line_num += $find_forwards * $find_direction;
		# first, separate the '{' and '}' cases !
		if ($c eq '{') {
			while ($line_num >= $[) {
				# 20200506 if BOF then go to beginning of first line,
				if ($line_num == $[) {
					$found_single = 1;   $char_num = $[;   last
				} elsif ($Lines[$line_num] =~ /^\s*$/ and
				       $Lines[$line_num-1] =~ /\S/) {
					$found_single = 1;   $char_num = $[;   last
				}
				$line_num -= 1;
			}
		} elsif ($c eq '}') {
			# find the empty line after this para, not the start of the next
			while ($line_num <= $#Lines) {
				# XXX 20200506 if EOF then go to end of last line
				if ($line_num == $#Lines) {
					$found_single = 1;
					$char_num = $[ - 1 + length $Lines[$line_num];   last
				} elsif ($Lines[$line_num] =~ /^\s*$/ and
				       $Lines[$line_num-1] =~ /\S/) {
					$found_single = 1;   $char_num = $[;   last
				}
				$line_num += 1;
# XXX correctly placed; but deleting must now be special-cased to
#     delete the last character also...
			}
		} else {
			while ($line_num >= $[ and $line_num <= $#Lines) {
				if ($Lines[$line_num] =~ /$find_string/) {
					$found_single = 1;
					if ($c eq 'b') { $char_num =  length $1;
					} else { $char_num = length $`;  # length of the PREMATCH
					}
					last;
				}
				$line_num += $find_forwards * $find_direction;
			}
		}
		if (! $found_single) { return(); }
	}
	return ($line_num, $char_num);
}

sub quit_dialogue {
	if ($FileIsChanged) {
		message('No write since last change (q-bang to override)');
		return;
	}
	if (@ARGV > 0) {
		my $s = 'files';  if (1 == @ARGV) { $s = 'file'; }
		message(sprintf("%d more $s to edit", scalar @ARGV));
		gotoxy(charnum2colnum($CharNum), $DisplayLine);
		return;
	}
	gotoxy(0, $DisplayLine+1); # clrtoeol();
	set_default($FileName, "$LineNum");
	exit 0;
}

sub read_dialogue { my $arg = $_[$[];
	my $filename = $arg;
	$filename =~ s/^~\//$HOME\//;
	if (! open(F, '<', $filename)) {
		message("can't open $filename : $!"); return 0;
	}
	my @buffer = <F>;  close F;
	if (! @buffer) { message("empty file"); return 0; }
	foreach (@buffer) { s/\n$//; }
	if ($CharNum == $[) { splice(@Lines, $LineNum, 0, @buffer); # if at BOL
	} elsif ($LineNum == $#Lines) { push @Lines, @buffer;
	} else { splice(@Lines, $LineNum+1, 0, @buffer);
	}
	$FileIsChanged = 1;
	my $lines = scalar(@buffer);  message("$lines lines from $arg");
}

sub save_dialogue {  my ($file, $option) = @_;
	if ($file) {
		if (! open(F, '>', $file)) { message($!); return 0; }
		foreach (@Lines) { print F $_,"\n"; }
		close F;
		message(sprintf("%d lines saved", scalar @Lines), $option);
		return;
	}
	if ($ReadOnly) { message("sorry, readonly."); return 0; }  # 2.0
	if ($FileIsChanged) {
		if ($FileLastSaved < mtime($FileName)) { # someone else updated it
			message("something else has changed it: bang to overwrite");
			if (getch() ne '!') { return 0; }
		}
	}
	if (! open(F, '>', $FileName)) { message($!); return 0; }
	foreach (@Lines) { print F $_,"\n"; }
	close F;
	$FileIsChanged = 0;
	$FileLastSaved = time;
	message(sprintf("%d lines saved", scalar @Lines), $option);
}

sub insert_mode {  my ($arg, $replace) = @_;
	# this should be invoked only from sub perform_a_change
	# warning for substr: when appending, CharNum can lie beyond end-of-string
	if (defined $arg) {   # if $arg is set (by '.'), we insert it here
# BUG if $arg multiline
		$Lines[$LineNum] = my_substr($Lines[$LineNum], $CharNum, 0, $arg);
		message();
		return;
	}
	$InsertMode = 1;  # to special-case display_line and charnum2colnum
	my @text = ();
	my $DcharsSoFar = 0;
	while (1) {   # the insert LOOP
		my $c = getch();
		if ($c eq "\e") {
			$InsertMode = 0;   constrain_char_num();
			if (@text) { $StoreLastChange{'text'} = join '',@text; }
			# should do multiple inserts...
			$LastWasUpOrDown = 0; $LastWasLineNum = 0;
			message();  display_line();  return;
		} elsif ($c eq "\r") {
			if ($replace eq 'R') { next; }
			my $pre = substr $Lines[$LineNum], $[, $CharNum-$[, '';
			splice @Lines, $LineNum, 0, ''.$pre;
			$Icol = $CharNum;   # 2.0 bugfix
			$LineNum += 1; $CharNum = $[; push @text, $c;
			message("line ".($LineNum+1-$[).' INSERT');
			display_line();
		} elsif ($c == $KEY_LEFT) {
			if ($CharNum > $[) {
				my $oldcolnum = charnum2colnum($CharNum);
				$CharNum -= 1;
				my $newcolnum = charnum2colnum($CharNum);
				left($oldcolnum-$newcolnum);
			}
		} elsif ($c == $KEY_RIGHT) {
			if ($CharNum < (length($Lines[$LineNum])-1+$[)) {
				my $oldcolnum = charnum2colnum($CharNum);
				$CharNum += 1;
				my $newcolnum = charnum2colnum($CharNum);
				right($newcolnum-$oldcolnum);
			}
		} elsif ($c == $KEY_DELETE) {   # even at EOL!
			if ($CharNum < (length($Lines[$LineNum])-1+$[)) {
				substr $Lines[$LineNum], $CharNum, 1, '';
				display_line();  # this is where we needed smdc and rmdc :-(
			}
		} elsif ($c == $KEY_UP or $c == $KEY_DOWN) {
			message('UP and DOWN are not supported in insert mode');
		} elsif ($c eq "\cH" or $c eq "\x7f") {  # \cH (even at BOL!)
			if ($CharNum > $[) {   # CharNum=$[ means EITHER one char, OR null
				if ($CharNum >= ($[ -1 + length $Lines[$LineNum])) {
					$Lines[$LineNum] =~ s/.$//;
				} else {
					substr $Lines[$LineNum], $CharNum-1, 1, '';
				}
				$CharNum -= 1;
				display_line();  # this is where we needed smdc and rmdc :-(
			}
		# UP DOWN & PAGEkeys should add_to_history, but remain in InsertMode
		# insert_mode should probably line-wrap by default...    XXX
		# backspace in InsertMode doesn't do anything, but $Dch1 works
		# Inserting doesn't work into a line which is already over-length
		# should charnum2colnum take account of long lines ?
		# XXX 20150904 with yasr, backspace, especially at EOL,
		#   must speak the deleted char, not the whole line !
		} elsif ($c eq "\t") {
			my $oldcolnum = charnum2colnum($CharNum);
			my $r = 0 ; if ($replace eq 'R') { $r = 1; } # 2.1
			$Lines[$LineNum] = my_substr($Lines[$LineNum], $CharNum, $r,"\t");
# XXX linewrap ?
			$CharNum += 1; push @text, $c;
			my $newcolnum = charnum2colnum($CharNum);
			if (length(expand_tabs()) >= $Cols) {
				# to use $Dch1 at BOL we have to go there and then get back
				left($oldcolnum-1); puts($Dch1); right($oldcolnum-2);
			}
# 20150914 2.1 replace mode with a tab is not so trivial...
			puts($Smir.' 'x($newcolnum-$oldcolnum).$Rmir);
		} else {
			my $r = 0 ; if ($replace eq 'R') { $r = 1; } # 2.1
			$Lines[$LineNum] = my_substr($Lines[$LineNum], $CharNum, $r, $c);
# XXX linewrap ?
			my $colnum = charnum2colnum($CharNum);  # 1.9
			if (length(expand_tabs()) >= $Cols) {
				left($colnum-$DcharsSoFar); puts($Dch1);
				right($colnum-$DcharsSoFar-1);
				$DcharsSoFar += 1;
			}
			# yasr does not speak the inserted char, but speakup does
			if ($replace eq 'R') { puts($c); } else { puts($Smir.$c.$Rmir); }
			$CharNum += 1; push @text, $c;
			if ($Opt{'keyecho'}) { left(1); puts($c); }
		}
	}
	warn "shouldn't reach here";
}

sub my_substr { my ($str, $offset, $length, $replacement) = @_;
	# NB: this can not modify $str, so it's not a drop-in replacement...
	if ($offset > ($[ - 1 + length $str)) { return $str.$replacement;
	} else { substr($str,$offset,$length,$replacement);  return $str;
	}
}

sub mtime {
	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	  $atime,$mtime,$ctime,$blksize,$blocks) = stat($_[$[]);
	return $mtime;
}

sub round { my $x = $_[$[];
	if ($x > 0.0) { return int ($x + 0.5); }
	if ($x < 0.0) { return int ($x - 0.5); }
	return 0;
}


sub consult_vimrc {
	my $h = $HOME;
	foreach my $file ("$h/.vimrc",'.nexrc','.exrc',"$h/.nexrc","$h/.exrc") {
		if (open(F, '<', $file)) {
			while (<F>) {
				if (/^\s*set\s+tabstop=(\d+)/) { $Opt{'tabstop'} = 0+$1; }
				if (/^\s*set\s+nowrap/)        { $Opt{'wrap'}    = 0; }
			}
			close F;
		}
	}
	return;
}

sub handle_command { my $cmd = $_[$[];
	if ($cmd eq 'q') { exit;
	} elsif ($cmd eq '.=') { print $LineNum+1-$[, "\r\n";
	} elsif ($cmd eq '=')  { print "$#Lines\r\n";
	} elsif ($cmd eq 'd')  {
		if (@Lines) { splice @Lines, $LineNum, 1; }
	} elsif ($cmd eq 'n')  {
		my $x=$LineNum+1-$[; print "$x ".$Lines[$LineNum]."\r";
	} elsif ($cmd eq 'p')  { print $Lines[$LineNum]."\r";
	}
}

sub is_yasr {
	# defunct; can't possible handle ssh
	my $ppid = getppid;
	foreach (1...4) {
		if (1 == $ppid) { return 0; }
		my $pnam = `ps -p $ppid -o comm=`;
		if ($pnam =~ /^yasr/) { return 1; }
		$ppid = 0 + `ps -p $ppid -o ppid=`;
	}
	return 0;
}

sub message { my ($s, $option) = @_;
	if (! $s) {
		if ($LineNum == $LastWasLineNum) { $s = '';   # 2.0
		} else { $s = "line ".($LineNum+1-$[);  $LastWasLineNum = $LineNum;
		}
	}
	if ($LastWasUpOrDown) {
		$s = ''; puts_xy_clr(0, $DisplayLine+1, $s);
		$LastWasUpOrDown = 0;
	} elsif ($s ne $LastMessage) {
		# 20150914 dont rewrite the word 'line' if it's already there
		if ($LastMessage =~ /^line / and $s =~ /^line (.+)$/) {
			puts_xy_clr(5, $DisplayLine+1, $1);
		} else {
			puts_xy_clr(0, $DisplayLine+1, $s);
		}
	}
	if ($option ne 'quitting') {
		gotoxy(charnum2colnum($CharNum),$DisplayLine);
	}
	$LastMessage = $s;
}

sub add_to_history {   # 20130718 still just single-level, like Sun vi
	# unlike in midiedit, this should be called _before_ any modification
	# Diff::LibXDiff
	# or, a lot easier to install:  Text::Diff  Algorithm::Diff  Text::Patch
	# @HistoryGoBack = ();     # list of patches
	# @HistoryGoForward = ();  # list of patches
	$HistoryMostRecent = join("\n",@Lines)."\n";
	$HistoryLineNums[$[] = $LineNum;  # save LineNum
	$HistoryCharNums[$[] = $CharNum;  # save CharNum
	# should we save the marks also ?  and FileIsChanged also ?
	$FileIsChanged = 1;
}
sub re_do {   # 20130718 still just single-level, like Sun vi
	my $tmp = join("\n",@Lines)."\n";
	@Lines = split("\n", $HistoryMostRecent);  chomp @Lines;
	$HistoryMostRecent = $tmp;
	# $tmp = $LineNum;  what's this for?
	$LineNum = $HistoryLineNums[$[];  # restore LineNum
	$CharNum = $HistoryCharNums[$[];  # restore CharNum
	message(); display_line();
}
sub un_do {   # 20130718 still just single-level, like Sun vi
	my $tmp = join("\n",@Lines)."\n";
	@Lines = split("\n", $HistoryMostRecent);  chomp @Lines;
	$HistoryMostRecent = $tmp;
	# $tmp = $LineNum;  what's this for?
	$LineNum = $HistoryLineNums[$[];  # restore LineNum
	$CharNum = $HistoryCharNums[$[];  # restore CharNum
	message(); display_line();
}

sub delete_between { my ($line1, $char1, $line2, $char2) = @_;
	# Used by eg: d5w d2} cw c} !}fmt :.,$d
	# Because it is used by ! it returns the text deleted.
	# it sets @Buffer but it can't set $BufferIsWholeLine  (2dd is, d9w isn't)
	if ($line2 < $line1) {
		my $tmp=$line1; $line1=$line2; $line2=$tmp;
		   $tmp=$char1; $char1=$char2; $char2=$tmp;
	} elsif ($line1 == $line2) {
		if ($char1 == $char2) {
			message('0 chars');  display_line();  return '';
		} elsif ($char2 < $char1) {
		   my $tmp=$char1; $char1=$char2; $char2=$tmp;
		}
	}
	$LineNum = $line1;  $CharNum = $char1;
	if ($line1 == $line2) {
		my $nchars  = $char2-$char1;
		my $deleted = substr $Lines[$line1], $char1, $nchars, '';
		my $msg = "1 char";  if ($nchars > 1) { $msg = "$nchars chars"; }
		message($msg);  display_line();
		@Buffer = ( $deleted );
		return $deleted;
	} else {
		my @deleted = ();  my $nlines;
		my $end_of_first_line   = substr $Lines[$line1], $char1;
		$Lines[$line1]          = substr $Lines[$line1], $[, $char1-$[;
		if (($char2-$[) < length($Lines[$line2])) {
			my $start_of_final_line = substr $Lines[$line2],$[,$char2-$[,'';
			$Lines[$line1] .= $Lines[$line2];
			@deleted = splice @Lines, $line1+1, $line2-$line1;
			push @deleted, $start_of_final_line;
			$nlines  = $line2-$line1;
		} else {   # 20200507 past EOL is used as a signal for d} to EOF
			@deleted = splice @Lines, $line1+1, $line2-$line1+1;
			pop @Lines; if ($LineNum > $[) { $LineNum = $LineNum-1; } # 2.4
			$nlines  = $line2-$line1+1;
		}
		unshift @deleted, $end_of_first_line;
		# we don't say "lines deleted" because it might be !}
		my $msg = "1 line";  if ($nlines > 1) { $msg = "$nlines lines"; }
		message($msg);  display_line();
		@Buffer = @deleted;   return join("\n",@deleted);
		if (! @Lines) { @Lines = (); }   # 2.3 20200508
	}
	warn "BUG: shouldn't reach here...";
}

sub debug {
    open (T, '>>', '/tmp/debug');
    print T $_[$[],"\n";
    close T;
}

sub write_spoken { my $s = $_[$[];
	# examine text to guess if punctuation should be pronounced;
	# if inconclusive, go with what was done last time.
	if ($Opt{'reader'} eq 'yasr') {  # write to STDOUT
	} else {
	}
}
sub write_silent { my $s = $_[$[];
	if ($Opt{'reader'} eq 'yasr') { # kludge with Smir Rmir; insert is silent!
	} else {
	}
}

# --------------- terminfo stuff ---------------
sub get_smir_rmir_dch1 {   # for use in insert_mode...
	my $smir = '';  my $rmir = '';  my $dch1 = '';
    # man terminfo:
    # enter_insert_mode         smir       im        enter insert mode
    # exit_insert_mode          rmir       ei        exit insert mode
    # These were not present in vt100, but are in vt220 and xterm.
	# The following would be useful but are not present in vt220 or xterm:
	# enter_delete_mode         smdc       dm        enter delete mode
	# exit_delete_mode          rmdc       ed        end delete mode
	eval 'require Term::Terminfo'; if (! $@) {
		# needs ExtUtils::CChecker, Test::Fatal, Test::Tiny and Try::Tiny;
    	# and preferably also Test::Pod and Sub::Name :-(
		my $ti = Term::Terminfo->new();
		# Capabilities each have two names; a short name called the capname,
		# and a longer name called the varname. $ti->str_by_varname($varname)
		$smir = $ti->getstr('smir');
		$rmir = $ti->getstr('rmir');
		$dch1 = $ti->getstr('dch1');
	} else {
		if (open(P, '-|', 'tput smir')) { $smir = <P>; } close P;
		if (open(P, '-|', 'tput rmir')) { $rmir = <P>; } close P;
		if (open(P, '-|', 'tput dch1')) { $dch1 = <P>; } close P;
	}
	return ($smir, $rmir, $dch1);
}

# --------------- dbm stuff, evolved from Term::Clui ---------------
sub get_default { my ($question) = @_;
	if ($ENV{CLUI_DIR} =~ /off/i) { return undef; }
	if (! $question) { return undef; }
	my @choices;
	my $n_tries = 5;
	while ($n_tries--) {
		if (dbmopen (%CHOICES, &dbm_file(), 0600)) {
			last;
		} else { 
			if ($! eq 'Resource temporarily unavailable') {
				my $wait = rand 0.45; select undef, undef, undef, $wait;
			} else { return undef;
			}
		}
	}
	@choices = split ($; ,$CHOICES{$question}); dbmclose %CHOICES;
	if (wantarray) { return @choices;
	} else { return $choices[$[];
	}
}
sub set_default { my $question = shift; my $s = join($; , @_);
	if ($ENV{CLUI_DIR} =~ /off/i) { return undef; }
	if (! $question) { return undef; }
	my $n_tries = 5;
	while ($n_tries--) {
		if (dbmopen(%CHOICES, &dbm_file(), 0600)) {
			last;
		} else { 
			if ($! eq 'Resource temporarily unavailable') {
				my $wait = rand 0.50; select undef, undef, undef, $wait;
			} else { return undef;
			}
		}
	}
	$CHOICES{$question} = $s; dbmclose %CHOICES;
	return $s;
}
sub dbm_file {
	if ($ENV{CLUI_DIR} =~ /off/i) { return undef; }
	my $db_dir;
	if ($ENV{CLUI_DIR}) {
		$db_dir = $ENV{CLUI_DIR};
		$db_dir =~ s#^~/#$HOME/#;
	} else { $db_dir = "$HOME/.clui_dir";
	}
	mkdir ($db_dir,0750);
	return "$db_dir/vibe";
}


# --------------- vt100 stuff, evolved from Term::Clui ---------------
sub initscr {
	open(TTY, '>', '/dev/tty')
	 || (warn "Can't write /dev/tty: $!\n", return 0);
	open(TTYIN, '<', '/dev/tty')
	 || (warn "Can't read /dev/tty: $!\n", return 0);
	Term::ReadKey::ReadMode('ultra-raw', *TTYIN);
	select((select(TTY), $| = 1)[$[]); print TTY q{};
	$rin = q{}; vec($rin, fileno(TTYIN), 1) = 1;
	$Icol = 0; $Irow = 0;
}
sub puts   { my $s = join q{}, @_;
	$Irow += ($s =~ tr/\n/\n/);
	if ($s =~ /\r\n?$/) { $Icol = 0;
	} else { $Icol += length($s);   # BUG, wrong on multiline strings!
	}
	print TTY $s;
}
sub puts_silent   { my $s = join q{}, @_;
	$Irow += ($s =~ tr/\n/\n/);
	if ($s =~ /\r\n?$/) { $Icol = 0;
	} else { $Icol += length($s);   # BUG, wrong on multiline strings!
	}
	print TTY $s;  # NOPE, this fails to bypass yasr :-(
}
sub endwin {
	print TTY "\e[0m";
	Term::ReadKey::ReadMode('restore', *TTYIN);
	close TTY; close TTYIN;
}
sub puts_30c {  my $s = $_[$[];   # assumes no newlines
	my $rest = 30-length($s);
	print TTY $s, " "x$rest, "\e[D"x$rest;
	$Icol += length($s);
}
sub clrtoeol {
	print TTY "\e[K";
}
sub getc_wrapper { my $timeout = 0 + $_[$[];
	return Term::ReadKey::ReadKey($timeout, *TTYIN);
}
sub getch {
	my $c = getc_wrapper(0);
	if ($c eq "\e") {
		$c = getc_wrapper(0.10);
		if (! defined $c) { return("\e"); }
		if ($c eq 'A') { return($KEY_UP); }
		if ($c eq 'B') { return($KEY_DOWN); }
		if ($c eq 'C') { return($KEY_RIGHT); }
		if ($c eq 'D') { return($KEY_LEFT); }
		if ($c eq '2') { getc_wrapper(0); return($KEY_INSERT); }
		if ($c eq '3') { getc_wrapper(0); return($KEY_DELETE); } # 1.54
		if ($c eq '5') { getc_wrapper(0); return($KEY_PPAGE); }
		if ($c eq '6') { getc_wrapper(0); return($KEY_NPAGE); }
		if ($c eq 'Z') { return($KEY_BTAB); }
		if ($c eq '[' or $c eq 'O') {
			$c = getc_wrapper(0);
			if ($c eq 'A') { return($KEY_UP); }
			if ($c eq 'B') { return($KEY_DOWN); }
			if ($c eq 'C') { return($KEY_RIGHT); }
			if ($c eq 'D') { return($KEY_LEFT); }
			if ($c eq 'F') { return($KEY_END); }   # 1.67
			if ($c eq 'H') { return($KEY_HOME); }  # 1.67
			if ($c =~ /\d/) { my $c1 = getc_wrapper(0);
				if ($c1 eq '~') {
					if ($c eq '2') { return($KEY_INSERT);
					} elsif ($c eq '3') { return($KEY_DELETE);
					} elsif ($c eq '5') { return($KEY_PPAGE);
					} elsif ($c eq '6') { return($KEY_NPAGE);
					}
				} else {   # cursor-position report, response to \e[6n
					$AbsCursY = 0 + $c;
					while (1) {
						last if $c1 eq ';';
						$AbsCursY = 10*$AbsCursY + $c1;
						# debug("c1=$c1 AbsCursY=$AbsCursY");
						$c1 = getc(TTYIN);
					}
					$AbsCursX = 0;
					while (1) {
						$c1 = getc(TTYIN);
						last if $c1 eq 'R';
						$AbsCursX = 10*$AbsCursX + $c1;
					}
					return getch();
				}
			}
			if ($c eq 'Z') { return($KEY_BTAB); }
			return($c);
		}
		return($c);
	} else {
		return($c);
	}
}
sub up	{
	# if ($_[$[] < 0) { down(0 - $_[$[]); return; }
	print TTY "\e[A" x $_[$[]; $Irow -= $_[$[];
}
sub down  {
	# if ($_[$[] < 0) { up(0 - $_[$[]); return; }
	print TTY "\n" x $_[$[]; $Irow += $_[$[];
}
sub right {
	# if ($_[$[] < 0) { left(0 - $_[$[]); return; }
	print TTY "\e[C" x $_[$[]; $Icol += $_[$[];
}
sub left  {
	# if ($_[$[] < 0) { right(0 - $_[$[]); return; }
	print TTY "\e[D" x $_[$[]; $Icol -= $_[$[];
}
sub gotoxy { my $newcol = shift; my $newrow = shift;
	if ($newcol == 0) { print TTY "\r" ; $Icol = 0;
	} elsif ($newcol > $Icol) { right($newcol-$Icol);
	} elsif ($newcol < $Icol) { left($Icol-$newcol);
	}
	if ($newrow > $Irow)	  { down($newrow-$Irow);
	} elsif ($newrow < $Irow) { up($Irow-$newrow);
	}
}
# 20150910 race-condition-avoidance stuff from midiloop : XXX needs fixing
# 1) STDERR=>TTY  2) Icol starts from 0 not 1
sub puts_xy { my ($newcol, $newrow, $raw_s, $extras) = @_;   # 3.2
    my @s = ($raw_s, $extras);
    $newcol = round($newcol); $newrow = round($newrow);
    if ($newrow > $Irow)  { $Icol=0; } # \n affects Icol, so detect it now
    # small newcols would be quicker with "\r" . ' 'x($newcol-1)
    if ($newcol <= 1) { unshift @s, "\r" ; $Icol = 0;
    } elsif ($newcol > $Icol) {
        unshift @s, "\e[C"x($newcol-$Icol); $Icol = $newcol;
    } elsif ($newcol < $Icol) {
        unshift @s, "\e[D"x($Icol-$newcol); $Icol = $newcol;
    }
    if ($newrow > $Irow)      {
        unshift @s, "\r"; # because of this we needed the $Icol=1
        unshift @s, "\n"x($newrow-$Irow); $Irow = $newrow;
    } elsif ($newrow < $Irow) {
        unshift @s, "\e[A"x($Irow-$newrow); $Irow = $newrow;
    }
    $Irow += ($raw_s =~ tr/\n/\n/);
    if ($raw_s =~ /\r\n?$/) { $Icol = 0;
    } else { $Icol += length($raw_s);  # BUG w multiline strings: no prob here
    }
    print TTY join q{}, @s;
}
sub puts_xy_clr { my ($x, $y, $s) = @_;
    $s =~ s/\t/ /g;
    puts_xy($x, $y, $s, "\e[K");
}
sub puts_clr {  my $s = $_[$[];   # assumes no newlines
    $s =~ s/\s/ /g;
    print TTY "$s\e[K";
    $Icol += length($s);
}



__END__

=pod

=head1 NAME

vibe - a vi-like line-editor designed to work with I<yasr> or I<speakup>

=head1 SYNOPSIS

 vibe filename
 vibe -c '$' ~/log/thoughts
 vibe -v        # prints the version
 perldoc vibe   # read the manual :-)

=head1 DESCRIPTION

This script is a line-based editor written, in I<Perl>,
to work well with I<speakup> or with I<yasr>,
and to be easy to learn for people familiar with I<vi>.
It is mostly keystroke-compatible with I<vi>.
It currently handles:

 h j k l 5j ArrowKeys PageUp/Down { } 0 $ w b e :123 :1 Home :$
 End /somestring /perlregexp[a-m]?\d+.txt$ J i I x p P dd d} c C D
 !!fmt !}fmt dw d5w yw yy y} u Ctrl-R ZZ :w :n :q :wq

and many combinations of the above, like B<.,$d>

Unlike I<vi>, B<cw> is not special-cased to mean B<ce>

It is currently in its early versions.
Currently, the "u" undo-command only stores one level of history
(like the old I<Sun> vi did).

=head1 OPTIONS

=over 3

=item I<-c {command}>

{command} will be executed as an Ex command
after the first file has been read.
If the {command} contains spaces it must be enclosed in quotes.
Note: Unlike in I<vim>, you can only use one "-c" command.
Examples:

 prompt> vibe -c '$' ~/log/events
 prompt> grep veb ~/.bashrc
 alias veb="/usr/local/bin/vibe -c '$'"

=item I<-v>

Prints version number.

=back

=head1 CONFIGURATION

So far, I<vibe> does not have its own configuration file.
It does consult the I<~/.vimrc> to extract the I<tabstop> line:
 set tabstop=4

( it could conceivably also use wrap and keyecho ... )

but its other configurables are set by environment variables:

=over 3

=item I<VIBE_READER>

Although I<vibe> works satisfactorily under both I<yasr> and I<speakup>,
it can optimise its speaking behaviour slightly
according to the screen-reader being used.
The difference is small, because the screen-reader is not necessarily 
on the same host as I<vibe>, so I<vibe> is not able to use
I</sys/accessibility/speakup/> or I</proc/speakup/> to achieve any
fine-grained control.
But still, set I<export VIBE_READER=speakup> if you are using I<speakup>.
The default is I<yasr>.

=item I<VIBE_KEYECHO>

If this variable is set, I<vibe> in insert mode will attempt to speak
each character as it is inserted.

=item I<CLUI_DIR>

This variable is shared with the I<Term::Clui> CPAN module.
The database $ENV{CLUI_DIR}/vibe or ~/.clui_dir/vibe is
used to remember the current line number between invocations.
This mechanism can be disabled by setting CLUI_DIR=OFF if you really want to.

=back

=head1 CHANGES

 20200510  2.4 f F ; and , now work
 20200508  2.3 fix crash if !}fmt swallows the whole file
 20200507  2.2 fix d$, and { to BOF, and } or d} to EOF
 20150914  2.1 'R' = REPLACE though tabs not well-handled yet
 20150910  2.0 introduce -R readonly; puts_xy_clr reduces race conditions 
 20150905  1.9 $LastWasUpOrDown reduces verbosity under yasr, :r works
 20130801  1.8 ce and yy work, . repeats inserts, yyp and yyP work
 20130731  1.7 bug fixes in insert; saves line-number between invocations
 20130730  1.6 delete_between and thence dw d5w d} !} 
 20130728  1.5 insert_mode, C o and O; approaching releasability
 20130724  1.4 factor perform_a_change out of the main LOOP
 20130715  1.3 separate find_position, handles also \d+, $, .+5 etc
 20130525  1.2 tab expansion seems to work
 20130524  1.1 command_mode up to proof-of-concept stage
 20130331  1.0 first version

=head1 AUTHOR

Peter J Billam   http://www.pjb.com.au/comp/contact.html

=head1 CREDITS

Based on I<vi>, I<yasr> and I<speakup>

=head1 SEE ALSO

 http://search.cpan.org/perdoc?Diff::LibXDiff
 or, a lot easier to install:
 http://search.cpan.org/perdoc?Text::Diff
 http://search.cpan.org/perdoc?Algorithm::Diff
 http://search.cpan.org/perdoc?Text::Patch

 http://search.cpan.org/perdoc?Term::Terminfo
 which unfortunately also needs:
 http://search.cpan.org/perdoc?ExtUtils::CChecker
 http://search.cpan.org/perdoc?Test::Fatal
 http://search.cpan.org/perdoc?Test::Tiny
 http://search.cpan.org/perdoc?Try::Tiny
 http://search.cpan.org/perdoc?Test::Pod
 http://search.cpan.org/perdoc?Sub::Name

 http://search.cpan.org/perdoc?Term::ReadKey
 http://www.pjb.com.au/
 perl(1).

=cut

