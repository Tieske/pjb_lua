#!/usr/bin/env lua
---------------------------------------------------------------------
--     This Lua5 script is Copyright (c) 2020, Peter J Billam      --
--                         pjb.com.au                              --
--  This script is free software; you can redistribute it and/or   --
--         modify it under the same terms as Lua5 itself.          --
---------------------------------------------------------------------
Version = '2.4  for Lua5' -- f F ; and , now work
VersionDate  = '10may2020'
Synopsis = [[
  vibe [filenames]
  vibe -R [filenames]       # edit read-only
  vibe -c '$' [filenames]   # run command :$ on startup
  vibe -h                   # see this helpful synopsis
  vibe -v                   # show the version
]]

local find   = string.find
local format = string.format
local gsub   = string.gsub
local len    = string.len
local match  = string.match
local rep    = string.rep
local sub    = string.sub

MinusC   = nil    -- the -c argument. but it should be a list of commands ...
ReadOnly = false  -- 2.0

IARG=1; while arg[IARG] ~= nil do
	if not find(arg[IARG], '^-[a-z]') then break end
	local first_letter = sub(arg[IARG],2,2)
	if first_letter == 'v' then
		local n = gsub(arg[0],"^.*/","",1)
		print(n.." version "..Version.."  "..VersionDate)
		os.exit(0)
	elseif first_letter == 'c' then
		IARG = IARG+1 ; MinusC = arg[IARG]
	elseif first_letter == 'R' then
		ReadOnly = true
	else
		local n = gsub(arg[0],"^.*/","",1)
		print(n.." version "..Version.."  "..VersionDate.."\n\n"..Synopsis)
		os.exit(0)
	end
	IARG = IARG+1
end

--
-- 20130412  The aim is to behave like vim -c 'set lines=2' (or perhaps 4?)
-- except to not use curses-code, so as to be in control of which
-- characters would be output to the screen, and in what order;
--   and to use this control to achieve the same optimal speech interface,
--   under both speakup and yasr.
-- I store the command-string already parsed into
--   multiplier,cmd,position etc, to ease the work that '.' has to do
-- Vi doesn't allow '.' on ':' ed-commands, but I've always thought it should
-- Wrap when inserting is perhaps desirable for a visually-impaired user;
--   but python suffers, and long lines can always be generated by J
-- 20200508 TODO: # finds previous occurence of word under cursor
-- 20200508 TODO: fX and FX go forward or backward to X in the current line
-- 20200509 TODO: ; repeats previous f or F seek and , in the other direction
--   fix long lines in insert mode
--   . should repeat the last insert, including the text inserted :-)


P  = require 'posix'    -- http://luaposix.github.io/luaposix/docs/
T  = require 'terminfo' -- http://pjb.com.au/comp/lua/terminfo.html
RK = require 'readkey'  -- http://pjb.com.au/comp/lua/readkey.html
RL = require 'readline' -- http://pjb.com.au/comp/lua/readline.html
G  = require 'gdbm'     -- http://pjb.com.au/comp/lua/lgdbm.html
_G.BITOPS = {}  -- global because load executes in the calling context
B = {}

lua_version = gsub(_VERSION, "^%D+", "")
if tonumber(lua_version) < 5.3 then  -- 1.74
    B = require 'bit'  -- LuaBitOp http://bitop.luajit.org/api.html
else
	local f = load([[
    _G.BITOPS.bor    = function (a,b) return a|b  end
    _G.BITOPS.band   = function (a,b) return a&b  end
    _G.BITOPS.rshift = function (a,n) return a>>n end
	]])
	f()
	B = _G.BITOPS
end

-------------------------- global variables ---------------------
function _debug(...)
	local DEBUG = io.open('/tmp/debug', 'a')
	local a = {}
	for k,v in pairs{...} do table.insert(a, tostring(v)) end
	DEBUG:write(table.concat(a),'\n') ; DEBUG:flush()
	DEBUG:close()
end

HOME = P.getpwuid(P.geteuid())['pw_dir'] or os.getenv('HOME')

function consult_vimrc ()
	-- to get $> in lua use P.geteuid() - UNDOCUMENTED !
	local h = P.getpwuid(P.geteuid())['pw_dir'] or os.getenv('HOME')
	for k,file in ipairs(
		{ h.."/.vimrc", '.nexrc', '.exrc', h.."/.nexrc", h.."/.exrc" }
	) do
		local F = io.open(file)
		if F then
			for s in F:lines() do
				if match(s, '^%s*set%s+tabstop=%d+') then
					local t = match(s, '^%s*set%s+tabstop=(%d+)')
					Opt['tabstop'] = tonumber(t)
				end
				if match(s, '^%s*set%s+nowrap') then
					Opt['wrap'] = false
				end
			end
			F:close()
		end
	end
	return;
end

local function round(x)
	if not x then return nil end
	return math.floor(x+0.5)
end
-- --------------- terminfo stuff ---------------
local TI = {}
TI['clr_eol']      = T.get('clr_eol')      or "\027[K"
TI['clr_eos']      = T.get('clr_eos')      or "\027[J"
TI['cursor_up']    = T.get('cursor_up')    or "\027[A"
TI['cursor_down']  = T.get('cursor_down')  or "\n"
TI['cursor_left']  = T.get('cursor_left')  or "\027[D"
TI['cursor_right'] = T.get('cursor_right') or "\027[C"
TI['clear_screen'] = T.get('clear_screen') or "\027[H\027[J"
function output_of(cmd)
	local F,msg = io.popen(cmd, 'r')
	if not F then 
		io.stderr:write("can't run "..cmd..": "..msg.."\n") ; return nil
	end
	local txt = F:read('*all') ; F:close()
	return txt  -- chomp any final \n ?
end
function get_smir_rmir_dch1 ()   -- for use in insert_mode...
	local smir = '';  local rmir = '';  local dch1 = ''
    -- man terminfo:
    -- enter_insert_mode         smir       im        enter insert mode
    -- exit_insert_mode          rmir       ei        exit insert mode
    -- These were not present in vt100, but are in vt220 and xterm.
	-- The following would be useful but are not present in vt220 or xterm:
	-- enter_delete_mode         smdc       dm        enter delete mode
	-- exit_delete_mode          rmdc       ed        end delete mode
	-- if T then
		smir = T.get('smir'); rmir = T.get('rmir'); dch1 = T.get('dch1')
	-- else
	-- 	smir = output_of('tput smir')
	-- 	rmir = output_of('tput rmir')
	-- 	dch1 = output_of('tput dch1')
	-- end
	return smir, rmir, dch1
end

local function up(n)
	-- if n < 0 then down(0-n); return end
	TTY:write(rep(TI['cursor_up'], n)); TTY:flush()
	Irow = Irow - n
end
local function down(n)
	-- if n < 0 then up(0-n); return end
	TTY:write(rep(TI['cursor_down'], n)); TTY:flush()
	Irow = Irow + n
end
local function right(n)
	-- if n < 0 then left(0-n); return end
	TTY:write(rep(TI['cursor_right'], n)); TTY:flush()
	Icol = Icol + n
end
local function left(n)
	-- if n < 0 then right(0-n); return end
	TTY:write(rep(TI['cursor_left'], n)); TTY:flush()
	Icol = Icol - n
end
function gotoxy (newcol, newrow)
	-- TTY:write(T.tparm(T.get('cup'),newcol,newrow))
--    if     newcol == 0   then TTY:write("\r") ; TTY:flush() ; Icol = 0
--    elseif newcol > Icol then right(newcol-Icol)
--    elseif newcol < Icol then left(Icol-newcol)
--    end
	TTY:write("\r"); TTY:flush(); Icol=0 if newcol>0 then right(newcol) end
    if     newrow > Irow then down(newrow-Irow)
    elseif newrow < Irow then up(Irow-newrow)
    end
--Icol = newcol
end
-- 20150910 race-condition-avoidance stuff from midiloop : XXX needs fixing
-- 1) STDERR=>TTY  2) Icol starts from 0 not 1
function puts_xy (newcol, newrow, raw_s, extras)
	-- print('raw_s='..raw_s) ; sleep(1)
    local s = {raw_s, extras}
    newcol = round(newcol); newrow = round(newrow)
    if newrow > Irow  then Icol=0 end -- \n affects Icol, so detect it now
    -- small newcols would be quicker with "\r" . ' 'x(newcol-1)
    if newcol <= 0 then table.insert(s, 1, "\r"); Icol = 0
    elseif newcol > Icol then
        table.insert(s,1, rep(TI['cursor_right'],newcol-Icol)); Icol = newcol
    elseif newcol < Icol then
        table.insert(s, 1, rep(TI['cursor_left'],Icol-newcol)); Icol = newcol
    end
    if newrow > Irow      then
        table.insert(s, 1, "\r") -- because of this we needed the Icol=1
        table.insert(s, 1, rep("\n", newrow-Irow)); Irow = newrow
    elseif newrow < Irow then
        table.insert(s, 1, rep(TI['cursor_up'], Irow-newrow)); Irow = newrow
    end
    Irow = Irow + select(2, gsub(raw_s,  '\n', '\n'))
    if find(raw_s, '\r\n?$') then Icol = 0
    else Icol = Icol + len(raw_s) -- w multiline strings bug is no prob here
    end
    TTY:write(table.concat(s, '')) ; TTY:flush()
end

function puts_xy_clr (x, y, s)
    s = gsub(s, '%s', ' ')
    puts_xy(x, y, s, TI['clr_eol'])
end

function puts_clr (s)   -- assumes no newlines
    s = gsub(s, '%s', ' ')
    TTY:write(s..TI['clr_eol']) ; TTY:flush()
    Icol = Icol + len(s)
end

-------------------------- global variables ---------------------

TTY            = nil
TTYIN          = nil
IsUtf8         = false
FileName       = ''
Lines          = {}
LineNum        = 1
CharNum        = 1
LastMessage    = ''   -- used by sub message
LastDisplay    = ''   -- used by sub display_line
FileIsChanged  = 0
FileLastSaved  = os.time()
Opt = {}
  Opt['reader']  = os.getenv('VIBE_READER') or 'yasr'
  Opt['keyecho'] = os.getenv('VIBE_KEYECHO') or false
  Opt['tabstop'] = 4
  Opt['wrap']    = 1
consult_vimrc()           -- consult ~/.vimrc to reset %Opt if necessary
DisplayLine    = 0
Buffer         = {}   --  array of lines
BufferIsWholeLine = 0 --  1 is yy, y}, .,$d   0 is d3w y$   etc
LinesPerPage   = 20   -- for KEY_NPAGE and KEY_PPAGE
FindString     = ''
FindForwards   = 1    -- / or ? == +1 or -1
SeekForwards   = 1    -- f or F == +1 or -1
LastSeekChar   = nil
ForceWholeLine = { ['$']=true, ['}']=true, ['{']=true,  }
-- c and d want the whole line
HistoryGoBack    = {} -- list of patches, see Text::Diff and Text::Patch
HistoryGoForward = {} -- list of patches, see Text::Diff and Text::Patch
HistoryLineNums  = {} -- list of LineNums
HistoryCharNums  = {} -- list of CharNums
Ihistory         = -1
InsertMode       = false
Mark2LineNum     = {}
Mark2CharNum     = {}
Prompt2Name = {
  ['/']='vibe_find', ['?']='vibe_find', ['!']='vibe_pipe', [':']='vibe_cmd',
}
StoreLastChange  = {}  -- perform_a_change remembers multiplier,range,cmd...
LastWasUpOrDown  = false  -- 20150905 1.9
LastWasLineNum   = false  -- 20150910 2.0
TmpFile          = "/tmp/vibe.$$";
Smir, Rmir, Dch1 = get_smir_rmir_dch1()   -- for use in insert_mode
Icol = 0
Irow = 0

-------------------- infrastructure --------------------

function warn(...)
	local a = {}
	for k,v in pairs{...} do table.insert(a, tostring(v)) end
	io.stderr:write(table.concat(a),'\n') ; io.stderr:flush()
end
function exit(rv)
	rv = rv or 0
	print "\r"; endwin(); os.exit(rv)
end
function die(...) warn(...);  exit(1) end

--[[
function splice(array, offset, length, list)   -- perl-compatible
	if type(list) ~= 'table' then die('splice: 4th arg must be a table') end
	local result = {}
	if not offset then return {} end
	if not length then length = -1 end
	for i = 1,(offset-1) do result[#result+1] = array[i] end
	for i,v in pairs(list) do result[#result+1] = v end
	if length < 0 then
		for i = offset, (#array+1-length) do result[#result+1] = array[i] end
	else 
		for i = (offset+length), #array   do result[#result+1] = array[i] end
	end
	-- XXX following perl, should this also remove the elements from array ?
	for i = offset, offset+length-1 do array[i] = array[i+length] end
	array[offset+length] = nil
	return result
end
]]
function splice(array, offset, length, list)   -- perl-compatible
	list = list or {}
	if type(list) ~= 'table' then die('splice: 4th arg must be a table') end
	local result = {}
	if not offset then return {} end
	if not length then length = -1 end
	for i = offset, offset+length-1 do result[#result+1] = array[i] end
	local after = {}
	for i = offset+length, #array do table.insert(after, array[i]) end
	for i = offset, #array do table.remove(array) end
	for i,v in ipairs(list) do table.insert(array, v) end
	for i,v in ipairs(after) do table.insert(array, v) end
	return result
end

function split(s, pattern, maxNb) -- http://lua-users.org/wiki/SplitJoin
	if not s or len(s)<2 then return {s} end
	if not pattern then return {s} end
	if maxNb and maxNb <2 then return {s} end
	local result = { }
	local theStart = 1
	local theSplitStart,theSplitEnd = find(s,pattern,theStart)
	local nb = 1
	while theSplitStart do
		table.insert( result, sub(s,theStart,theSplitStart-1) )
		theStart = theSplitEnd + 1
		theSplitStart,theSplitEnd = find(s,pattern,theStart)
		nb = nb + 1
		if maxNb and nb >= maxNb then break end
	end
	table.insert( result, sub(s,theStart,-1) )
	return result
end
function sleep (t)
	local sec = math.floor(t)
	local ns  = round((1000000000 * (t-sec)))
	P.nanosleep(sec,ns)
	return true
end

------------------------ vt100 stuff -------------------------

local A_NORMAL    =  0
local A_BOLD      =  1
local A_UNDERLINE =  2
local A_REVERSE   =  4
local KEY_UP     = 0403  -- hmm; these were octal, but in lua are decimal..
local KEY_LEFT   = 0404
local KEY_RIGHT  = 0405
local KEY_DOWN   = 0402
local KEY_ENTER  = "\r"
local KEY_INSERT = 0525
local KEY_DELETE = 0524
local KEY_HOME   = 0523
local KEY_END    = 0522
local KEY_PPAGE  = 0521
local KEY_NPAGE  = 0520
local KEY_BTAB   = 0541
local AbsCursX   = 0
local AbsCursY   = 0
local TopRow     = 0
local CursorRow;
local LastEventWasPress = false;  -- in order to ignore left-over button-ups


local function utf8len(str)
	if not str then return 0 end   -- 1.75  20170525
--[[	  UCS code      :       Bytes    (see man 7 utf8)
	x00000000-0x0000007F 0xxxxxxx
	x00000080-0x000007FF 110xxxxx 10xxxxxx
	x00000800-0x0000FFFF 1110xxxx 10xxxxxx 10xxxxxx
	x00010000-0x001FFFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	x00200000-0x03FFFFFF 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	x04000000-0x7FFFFFFF 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
--]]
	local length = 0
	local i = 1
	while i <= string.len(str) do
		local c = string.byte(str, i) 
		length = length + 1
		if     B.band(c, 128) == 0   then i = i + 1
		elseif B.band(c, 224) == 192 then i = i + 2
		elseif B.band(c, 240) == 224 then i = i + 3
		elseif B.band(c, 248) == 240 then i = i + 4
		elseif B.band(c, 252) == 248 then i = i + 5
		elseif B.band(c, 254) == 252 then i = i + 6
		else
			i = 1 + 1  -- ill-formed
			io.stderr:write(
			  'utf8len: bad byte '..tostring(i)..' = '..tostring(c)..'\n')
		end
	end
	return length
end

do
	local lang = os.getenv('LANG')
	local lc   = os.getenv('LC_TYPE')   
	if lang and find(string.lower(lang), 'utf8') then
		len = utf8len ; IsUtf8 = true
	elseif lc and find(string.lower(lc), 'utf8') then
		len = utf8len ; IsUtf8 = true
	end
end
-- x = 'Aéŝ'; print(x..' is '..tostring(len(x))..' characters long')

function initscr()
	TTY   = assert(io.open(P.ctermid(), 'a+')) -- the controlling terminal
	TTYIN = assert(io.open(P.ctermid(), 'r'))
	RK.ReadMode('ultra-raw', TTY);
	Icol = 0; Irow = 0; InitscrAlreadyRun = true
end

function endwin()
	TTY:write("\027[0m") ; TTY:flush()
	RK.ReadMode('restore', TTYIN)
	RK.ReadMode(1, TTY)  -- not necessary in Perl ? why not ?
	TTY:close()
	TTYIN:close()   -- os.execute('stty sane')
end

function puts(...)
	s = table.concat({...}, '')
	if not s then return end
	Irow = Irow + select(2, gsub(s, '\n', '\n'))  -- PiL p.179
	if find(s, '\r\n?$') then Icol = 0
	else Icol = Icol + len(s)
	end
	TTY:write(s) ; TTY:flush()
end
function puts_30c(s)
	local rest = 30 - len(s)
	TTY:write(s)
	TTY:write(rep(' ',rest))
	TTY:write(rep('\027[D',rest)) ; TTY:flush()
	Icol = Icol + len(s)
end
function clrtoeol ()  TTY:write(TI['clr_eol'])      TTY:flush() end
function getc_wrapper (timeout)
	local c = RK.ReadKey(timeout, TTYIN)
	return c
end
local function getch()  -- return multiple bytes if utf8
	local c = getc_wrapper(0)
	if c == "\027" then
		c = getc_wrapper(0.10)
		if c == nil then return "\027" end
		if c == 'A' then return KEY_UP end
		if c == 'B' then return KEY_DOWN end
		if c == 'C' then return KEY_RIGHT end
		if c == 'D' then return KEY_LEFT end
		if c == '2' then getc_wrapper(0); return KEY_INSERT end
		if c == '3' then getc_wrapper(0); return KEY_DELETE end -- 1.54
		if c == '5' then getc_wrapper(0); return KEY_PPAGE end
		if c == '6' then getc_wrapper(0); return KEY_NPAGE end
		if c == 'Z' then return KEY_BTAB end
		if c == 'O' then   -- 1.68 Haiku wierdness, inherited from old Suse
			c = getc_wrapper(0);
			if c == 'A' then return KEY_UP end    -- 1.68
			if c == 'B' then return KEY_DOWN end  -- 1.68
			if c == 'C' then return KEY_RIGHT end -- 1.68
			if c == 'D' then return KEY_LEFT end  -- 1.68
			if c == 'F' then return KEY_END end   -- 1.68
			if c == 'H' then return KEY_HOME end  -- 1.68
			return(c);
		end
		if c == '[' then
			c = getc_wrapper(0);
			if c == 'A' then return KEY_UP end
			if c == 'B' then return KEY_DOWN end
			if c == 'C' then return KEY_RIGHT end
			if c == 'D' then return KEY_LEFT end
			if c == 'F' then return KEY_END end   -- 1.67
			if c == 'H' then return KEY_HOME end  -- 1.67
			if c == 'M' then   -- mouse report - we must be in BYTES !
				-- http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
				local event_type = B.band(127,string.byte(getc_wrapper(0)))-32
				local x = B.band(127,string.byte(getc_wrapper(0)))-32
				local y = B.band(127,string.byte(getc_wrapper(0)))-32
				-- local shift   = event_type & 0x04; -- used by wm
				-- local meta	= event_type & 0x08;   -- used by wm
				-- local control = event_type & 0x10; -- used by xterm
				local button_drag = B.rshift(B.band(event_type, 32), 5)
				local button_pressed;
				local low3bits = B.band(event_type, 3)
				if low3bits == 3 then
					button_pressed = 0
				else  -- button 4 means wheel-up, button 5 means wheel-down
					if B.band(event_type, 64) ~= 0 then
						button_pressed = low3bits + 4
					else
						button_pressed = low3bits + 1
					end
				end
				return handle_mouse(x,y,button_pressed,button_drag) or getch()
			end
			if match(c, '%d') then
				local c1 = getc_wrapper(0.05);
				if c1 == '~' then
					if     c == '2' then return KEY_INSERT
					elseif c == '3' then return KEY_DELETE
					elseif c == '5' then return KEY_PPAGE
					elseif c == '6' then return KEY_NPAGE
					end
				else   -- cursor-position report, response to \027[6n
					AbsCursY = tonumber(c)
					while true do
						if c1 == ';' then break end
						AbsCursY = 10*AbsCursY + (tonumber(c1) or 0) -- 1.76
						c1 = TTY:read(1)
					end
					AbsCursX = 0
					while true do
						c1 = TTY:read(1)
						if c1 == 'R' or not c1 then break end -- 1.73
						AbsCursX = 10*AbsCursX + (tonumber(c1) or 0) -- 1.76
					end
					return getch()
				end
			end
			if c == 'Z' then return KEY_BTAB end
			return c
		end
		return c
	elseif IsUtf8 then
		local b = string.byte(c)
		local nbytes = 1
		if     B.band(b, 224) == 192 then nbytes = 2
		elseif B.band(b, 240) == 224 then nbytes = 3
		elseif B.band(b, 248) == 240 then nbytes = 4
		elseif B.band(b, 252) == 248 then nbytes = 5
		elseif B.band(b, 254) == 252 then nbytes = 6
		end
		if nbytes == 1 then return c end
		local str_a = {c}  -- it's a uft8 character
		for i = 2,nbytes do str_a[#str_a+1] = getc_wrapper(0) end
		return table.concat(str_a, '')
	else
		return c
	end
end

-- --------------- dbm stuff, evolved from CommandLineUI ---------------
local function homedir(user)
    if not user and os.getenv('HOME') then return os.getenv('HOME') end
    if not user then user = P.getpid('euid') end
    return P.getpasswd(user, 'dir') or '/tmp'
end
local function tilde_expand(filename)
    if match(filename, '^~') then
        local user = match(filename, '^~(%a+)/')
        local home = homedir(user)
        filename = gsub(filename, '^~%a*', home)
    end
    return filename
end
local function dbm_file()
    local db_dir
    if os.getenv('CLUI_DIR') then
        if find(string.lower(os.getenv('CLUI_DIR'),'off')) then return nil end
        db_dir = tilde_expand(os.getenv('CLUI_DIR'))
    else
        db_dir = HOME..'/.clui_dir'
    end
    P.mkdir(db_dir)
    return db_dir..'/choices.gdbm'
end
function get_default (question)
	if os.getenv('CLUI_DIR') and
	  find(string.lower(os.getenv('CLUI_DIR'),'off')) then return nil end
	if not question then return nil end
	local db
	local dbfile = dbm_file()
	for n_tries=1,5 do
		db = G.open(dbfile, "c")
		if db then break end
		sleep( 0.25 * math.random() )
	end
	local choices = split(db:fetch(question) or '', '\028')  -- Perl $;
	db:close()
	if wantarray then return choices else return choices[1] end
end
function set_default (question, ...)
	local s = table.concat({...}, '\028')  -- Perl $;
	if os.getenv('CLUI_DIR')
	  and find(string.lower(os.getenv('CLUI_DIR'),'off')) then return nil end
	if not question then return nil end
	local db
	local dbfile = dbm_file()
	for n_tries=1,5 do
		db = G.open(dbfile, "w")
		if db then break end
		sleep( 0.35 * math.random() )
	end
	if not db:insert(question,s) then db:replace(question,s) end
	db:close()
	return s
end

--------------------- file stat infrastructure ----------------
function is_directory (fn)
	local s = P.lstat(fn)
	if not s then return false end
	return ( 0 ~= P.S_ISDIR(s['st_mode']) )
end
function exists(fn)
	if P.stat(fn) then return true else return false end
end
function is_writeable (fn)
	local fp = io.open(fn, 'a')
	if fp then fp:close() ; return true
	else return false
	end
end
function mtime (filename)
	return P.stat(filename)['st_mtime']
end

------------------- vibe infrastructure ------------------
function constrain_char_num ()
	-- the problem is that if the line has one char, then $CharNum = 1
	-- but if the line is empty, then $CharNum=-1 causes all substr to crash
	if CharNum <= 1 then CharNum = 1; return end
	-- in Append mode, CharNum can be one beyond the EOL...
	local max = len(Lines[LineNum])
	if CharNum > max then CharNum = max end
	return
end
function constrain_line_num ()
	if LineNum <= 1 then LineNum = 1; return end
	if LineNum > #Lines then LineNum = #Lines end
	return
end
function charnum2colnum (charnum)  -- closely related to expand_tabs
    if charnum < 1 then charnum = 1 end
    local colnum = 0
    -- local chars  = split('', Lines[LineNum]) NOPE, sorry :-
    local chars  = {}
	for i = 1, len(Lines[LineNum]) do chars[i] = sub(Lines[LineNum],i,i) end
	if InsertMode then
    	if charnum > (#chars+1) then charnum = #chars+1 end
	else
    	if charnum > #chars then charnum = #chars end
	end
if charnum > 1 then
    for i = 1, charnum-1 do   -- for all the previous chars
        if chars[i] == "\t" then  -- depends on 1=0
            colnum = -1 +
			  Opt['tabstop'] * (1 + math.floor((colnum+1) / Opt['tabstop']))
        else
            colnum = colnum + 1
        end
    end
end
	return colnum
end
function expand_tabs ()   -- closely related to charnum2colnum
	local expanded = {}
    local colnum = 0
	--for i, c in ipairs(split('', Lines[LineNum])) do  NOPE, sorry :-(
	for i = 1, len(Lines[LineNum]) do
		local c = sub(Lines[LineNum], i, i)
		if c == "\t" then
			local old_colnum  = colnum
            colnum = -1 +
			  Opt['tabstop'] * (1 + math.floor((colnum+1)/Opt['tabstop']));
			table.insert(expanded, rep(' ',colnum-old_colnum))
		else
            colnum = colnum + 1
			table.insert(expanded, c)
		end
	end
	return table.concat(expanded, '')
end

function message (s, option)
	if  not s then
		if LastWasLineNum then s = ''   -- 2.0
		else s = "line "..tostring(LineNum) ; LastWasLineNum = true
		end
	end
	if LastWasUpOrDown then
		s = ''; puts_xy_clr(0, DisplayLine+1, s)
		LastWasUpOrDown = false
	elseif s ~= LastMessage then
		-- 20150914 dont rewrite the word 'line' if it's already there
		if string.match(LastMessage, '^line ') then
			local linenum = string.match(s, '^line (.+)$')
			if linenum then puts_xy_clr(5, DisplayLine+1, linenum) end
		else
			puts_xy_clr(0, DisplayLine+1, s)
		end
	end
	if option ~= 'quitting' then
		gotoxy(charnum2colnum(CharNum), DisplayLine)
	end
	LastMessage = s
end

function display_line ()
	-- Handle long lines by just displaying $Cols-1 of them at once, and
	-- h l Left Right w b 0 $ still work as expected; still some BUGS here..
	-- printing a char to the right col sends the cursor to the next line :-)
	-- gotoxy(0,$DisplayLine);
	local s      = expand_tabs()
	local colnum = charnum2colnum(CharNum)
	if len(s) > Cols then   -- test if the line is too long to fit
		local new_colnum = round((Cols-1) * colnum / len(s))
		local shave_off_start = colnum - new_colnum
		if shave_off_start > 0 then
			-- substr $s, 1, $shave_off_start, '';
			s = sub(s, shave_off_start+1)
			colnum = new_colnum
		end
		if len(s) >= Cols   then s = sub(s, Cols) end
	end
	-- test if the line is unchanged, and if so not redisplay it,
	-- except that in InsertMode, LastDisplay will be out of date
	if InsertMode or (s ~= LastDisplay) then
		puts_xy_clr(0, DisplayLine, s); LastDisplay=s
	end
	gotoxy(colnum, DisplayLine)
end

function read_line (prompt)
	gotoxy(0, DisplayLine+1); clrtoeol()
	endwin()
--	local name = Prompt2Name[prompt] or 'vibe_misc';
--	local term = RL.ReadLine(name)   -- don't understand this bit ...
--	local attribs = term['Attribs']
--	if name == 'vibe_find' then
--		$attribs->{completion_entry_functionend
--		  = $attribs->{list_completion_function};
--		$attribs->{completion_word} = ();  
--	end
   	local cmdstr = RL.readline(prompt)
	cmdstr = gsub(cmdstr, ' $','')
	initscr()
	TTY:write("\027[A") ; Irow = DisplayLine + 1; clrtoeol()
	return cmdstr
end
function is_position (s)
	if match(s, "^%d+$") or match(s, "^%.([-+]%d+)?$") then
		return true
	end
	if match(s, "^'[a-z]$") or match(s, "^%$(-%d+)?$") then
		return true
	end
	-- needs expanding to recognise everything that find_position can handle
	return false
end
function find_position (s)
	-- handling 123, and (\d*)?[.}^$nNwbe]([-+]\d+)?
	-- and returning ($line_num,$char_num) could then be used in d4w or
	-- in  .,}+4w /tmp/t  by being invoked twice by a general  sub range
	-- in vi, [nN] _is_ useable in a range, also in dn or d3n etc.
	-- handle also marks, eg: 'a
	-- message('s='..tostring(s)) ; sleep(2)
	local line_offset = tonumber(match(s, '([-+]%d+)$') or 0)
	if s == '.' then   -- 1.3
		local n = LineNum + line_offset
		if n > #Lines then n = #Lines elseif n < 1 then n = 1 end
		return n, 1
	elseif s == '$' then   -- 1.3
		local n = #Lines + line_offset
		if n > #Lines then n = #Lines elseif n < 1 then n = 1 end
		return n, 1;
	elseif match(s, '^%d+$') then   -- 1.3
		local n = tonumber(s) + line_offset
		if n > #Lines then n = #Lines elseif n < 1 then n = 1 end
		return n, 1
	elseif match(s, "^'([a-zA-Z])$") then   -- 1.3  
		local mark = match(s, "^'([a-zA-Z])$")
		if Mark2LineNum[mark] then
			return Mark2LineNum[mark], Mark2CharNum[mark] or 1
		else
			message("Mark "..mark.." not set") return {}
		end
	end
	-- the remaining possibilities can take multipliers...
	local t1,t2 = match(s, '^(%d*)(.)$')
	local multiplier = tonumber(t1) or 1; local c = t2
	local find_direction    = 1
	local find_string   = FindString
	local find_forwards = FindForwards
	-- see  %f[%w] and %f[%W]  PiL3 p207  in perl \b means word-boundary
	if     c == 'n' then find_direction =  1   -- next
	elseif c == 'N' then find_direction = -1   -- previous
	elseif c == 'w' then find_forwards  =  1; find_string = '%W%w'
	elseif c == 'b' then find_forwards  = -1; find_string = '%f[%w]'
	elseif c == 'e' then find_forwards  =  1; find_string = '%w%W'
	elseif c == '}' then find_forwards  =  1; find_string = '^%s*$'
	elseif c == '{' then find_forwards  = -1; find_string = '^%s*$'
	else message("BUG: find_position called with c=$c"); return;
	end
	local line_num = LineNum
	local char_num = CharNum
	for i = 1, multiplier do
		local found_single   = false
		-- first find from CharNum on the current line, unless { or }
		if c ~= '{' and c ~= '}' then
			if find_forwards > 0 then
				local remainder = sub(Lines[LineNum], char_num+1)
-- problem: %f[%w] matches not just %W%w but also ^%w of the remainder
				local n = find(remainder, find_string)
				if n then
					char_num = char_num + n
					if c == 'w' then char_num = char_num + 1 end
					found_single = true; goto nextmultiplier
				end
			else
				local previous = sub(Lines[LineNum], 1, char_num-1)
				local pre = match(previous, '(.*)'..find_string)
				if pre then
					char_num     = len(pre)
					if c == 'b' then char_num = char_num + 1 end
					found_single = true ; goto nextmultiplier
				end
			end
		end
		-- in any case, look through the subsequent lines
		line_num = line_num + find_forwards*find_direction
		-- first, separate the '{' and '}' cases !
		if c == '{' then
			while line_num >= 1 do
				-- 20200506 if BOF then go to beginning of first line,
				if line_num == 1 then
					found_single = true;   char_num = 1   break
				elseif match(Lines[line_num], '^%s*$') and
				       match(Lines[line_num-1], '%S') then
					found_single = true;   char_num = 1   break
				end
				line_num = line_num - 1
			end
		elseif c == '}' then
			-- find the empty line after this para, not the start of the next
			while line_num <= #Lines do
				-- XXX 20200506 if EOF then go to end of last line
				if line_num == #Lines then
					found_single = true
					char_num = len(Lines[line_num]);   break
				elseif match(Lines[line_num], '^%s*$') and
				       match(Lines[line_num-1], '%S') then
					found_single = true   char_num = 1   break
				end
				line_num = line_num + 1
-- XXX correctly placed; but deleting must now be special-cased
--     to delete the last character also...
			end
		else
			while line_num >= 1 and line_num <= #Lines do
				local n = find(Lines[line_num], find_string)
				if n then
					found_single = true
					if c == 'b' then char_num =  n
					else char_num = n -- ??length $`; length of the PREMATCH
-- XXX but in vibe.pl no capture has taken place so surely $1 is nil!
					end
					break
				end
				line_num = line_num + find_forwards*find_direction
			end
		end
		if  not found_single then return end
		::nextmultiplier::
	end
	return line_num, char_num   -- XXX or should this be a list ?
end
function goto_position (cmdstr, msg)
	local line_num, char_num = find_position(cmdstr)
	if line_num then
		LineNum = line_num; CharNum = char_num
		message();  display_line()
	else
		message(msg or (cmdstr.." not found"))
	end
end

function save_dialogue (file, option)
	if file then   -- write to a different file (SaveAs)
		local F,msg = io.open(file, 'w')
		if not F then message(msg); return 0 end
		for i,v in ipairs(Lines) do F:write(v.."\n") end
		F:close()
		message(format("%d lines saved", #Lines), option)
		return
	end
	if ReadOnly then message("sorry, readonly."); return nil end
	if FileIsChanged then -- has someone else updated it ?
		local s = P.stat(FileName)
		if s then
			local mtime = s['st_mtime']
			if mtime and (FileLastSaved < mtime) then
				message("something else has changed it: bang to overwrite");
				if getch() ~= '!' then return 0 end
			end
		end
	end
	local F,msg = io.open(FileName, 'w')
	if not F then message(msg); return 0 end
	for i,v in ipairs(Lines) do F:write(v.."\n") end
	F:close()
	FileIsChanged = false
	FileLastSaved = os.time()
	message(format("%d lines saved", #Lines), option)
end

function quit_dialogue ()
	if FileIsChanged then
		message('No write since last change (q-bang to override)'); return
	end
	if IARG < #arg then
		local s = 'files';  if IARG < #arg then s = 'file' end
		message(format("%d more %s to edit", #arg-IARG, s))
		gotoxy(charnum2colnum(CharNum), DisplayLine)
		return
	end
	gotoxy(0, DisplayLine+1); -- clrtoeol()
	set_default(FileName, LineNum)
	exit(0)
end

function read_dialogue (argument)
	local filename = argument
	gsub(filename, '^~/', HOME..'/', 1)
	local F,msg = io.open(filename, 'r')
	F:close()
	if not F then message("can't open "..filename.." : "..msg); return 0 end
	local buffer = {}
	for line in io.lines(filename) do buffer[#buffer+1] = line end
-- print ('io.lines('..filename)
	if #buffer == 0 then message("empty file"); return 0 end
	-- foreach (@buffer) do s/\n$//; end
	for i,v in ipairs(buffer) do buffer[i] = gsub(v, '\n$', '') end
	if CharNum == 1 then splice(Lines, LineNum, 0, buffer); -- if at BOL
	elseif LineNum == #Lines then
		for i,v in ipairs(buffer) do Lines[#Lines+1] = v end
	else splice(Lines, LineNum+1, 0, buffer)
	end
	FileIsChanged = true
	local lines = #buffer;  message("$lines lines from "..argument)
end

function delete_between (line1, char1, line2, char2, yank)
	-- Used by eg: d5w d2} cw c} !}fmt :.,$d
	-- Because it is used by ! it returns the text deleted.
	-- it sets @Buffer but it can't set $BufferIsWholeLine  (2dd is, d9w isn't)
--message('line1='..tostring(line1)..' char1='..tostring(char1)
--..'  line2='..tostring(line2)..' char2='..tostring(char2))
--sleep(2)
	if line2 < line1 then
		local tmp=line1; line1=line2; line2=tmp
		   tmp=char1; char1=char2; char2=tmp
	elseif line1 == line2 then
		if char1 == char2 then
			message('0 chars');  display_line();  return ''
		elseif char2 < char1 then
		   local tmp=char1; char1=char2; char2=tmp
		end
	end
	LineNum = line1;  CharNum = char1
	if line1 == line2 then
		local nchars  = char2-char1
		local before,this,after = split_3(Lines[line1], char1, nchars)
		if not yank then Lines[line1] = before .. after end
		local msg = "1 char"
		if nchars > 1 then msg = tostring(nchars).." chars" end
		message(msg);  display_line()
		Buffer = { this }
		return this
	else
		local nlines
		local end_of_first_line = sub(Lines[line1], char1)
		if not yank then Lines[line1] = sub(Lines[line1], 1, char1-1) end
		if (char2-1) < len(Lines[line2]) then
-- better use sub() ?
			local start_of_final_line = my_substr(Lines[line2],1,char2-1,'')
			if not yank then Lines[line1] = Lines[line1]..Lines[line2] end
			for i = line1+1, line2 do table.insert(Buffer, Lines[i]) end
			table.insert(Buffer, start_of_final_line)
			nlines  = line2-line1
		else   -- 20200507 past EOL is used as a signal for d} to EOF
			Buffer = splice(Lines, line1+1, line2-line1)
			if not yank then Lines[#Lines] = nil end
			if LineNum > 1 then LineNum = LineNum-1 end -- 2.4
			nlines  = line2-line1+1
		end
		table.insert(Buffer, 1, end_of_first_line)
		-- we don't say "lines deleted" because it might be !end
		local msg = "1 line"
		if nlines > 1 then msg = tostring(nlines).." lines" end
		message(msg);  display_line()
		if not yank and not Lines then Lines = {} end   -- 2.3 20200508
		return table.concat(Buffer,"\n")
	end
	warn "BUG: shouldn't reach here...";
end
function yank_between (line1, char1, line2, char2)
	delete_between(line1, char1, line2, char2, 'yank')
end

function colon_mode (s)   -- to handle the vibe -c arg
	-- colon_mode handles r w q (\d+) and /^$/,$-5 s/\t/    /g
	--  does filename-completion as necessary,
	--  and expects a \n to terminate the command.
	-- Term::ReadLine::Gnu does tab-completion for filenames by default...
	local line_num = 0
	local cmdstr = s or read_line(':')
	LastMessage = ":"..cmdstr
	gotoxy(0, DisplayLine+1)
	if is_position(cmdstr) then goto_position(cmdstr, "not found"); return end
--print('\rcolon_mode: before cmdstr = ',cmdstr)
--	local range,cmd,s = match(cmdstr,'([.%d]+,[.%d%$]+)?(%S+)%s*(.*)$')
--print('\r1 after range, cmd, s = ',range, cmd, s)
--	range = range or '' ; cmd = cmd or '' ; s = s or ''
--print('\r2 after range, cmd, s = ',range, cmd, s)
	local range, rest = match(cmdstr, '^([%.%d]+,[%.%d%$]+)(.+)$')
	if range then cmdstr = rest end
	local cmd, arg = match(cmdstr, '^(%S+)%s*(.*)$')
	if     cmd == 'q'   then quit_dialogue(); return
	elseif cmd == 'q!'  then arg={};  exit(0)
	elseif cmd == 'w'   then save_dialogue(); return
	elseif cmd == 'wq'  then save_dialogue(nil,'quitting'); quit_dialogue()
		return;
	elseif cmd == 'wq!' then save_dialogue(); arg={}; exit(0)
	elseif cmd == 'n'   then save_dialogue(); return 'next'
	elseif cmd == 'wn'  then save_dialogue(); return 'next' -- if write fails?
	elseif cmd == 'r'   then read_dialogue(arg) return
	-- 20150905 also delete and yank ?  see eg: delete_between()
	elseif cmd == 'd' or cmd == 'y'  then   -- 20200506 added 'y'
		local line1,line2 = split(range,',',2)
		local staline, stachar = find_position(line1)
		local endline, endchar = find_position(line2)
		if cmd == 'd' then
			delete_between(staline,0,endline,0) -- also .+4 $-2  +3 -17 etc
		end
		BufferIsWholeLine = true
		return
	elseif match(cmd, '^%d+') then  -- also .+4 $-2 etc... +3 -17 etc...
		LineNum = tonumber(cmd);  constrain_line_num()
		constrain_char_num(); message(); display_line(); return
	elseif cmd == '$' then
		LineNum = #Lines
		constrain_char_num(); message(); display_line(); return
	end
end

function add_to_history ()   -- 20130718 still just single-level, like Sun vi
	-- unlike in midiedit, this should be called _before_ any modification
	HistoryMostRecent = table.concat(Lines,"\n").."\n"
	HistoryLineNums[1] = LineNum  -- save LineNum
	HistoryCharNums[1] = CharNum  -- save CharNum
	-- should we save the marks also ?  and FileIsChanged also ?
	FileIsChanged = true
end

function my_substr (str, offset, length, replacement)
	if offset > len(str) then return str..replacement
	else -- substr($str,$offset,$length,$replacement);
		local before,this,after = split_3(str, offset, length)
		return before .. replacement .. after
	end
end

function insert_mode (argument, replace)
	-- this should be invoked only from sub perform_a_change
	-- warning for substr: when appending, CharNum can lie beyond end-of-string
	if argument then   -- if $arg is set (by '.'), we insert it here
-- BUG if argument multiline
		local before = sub(Lines[LineNum], 1, CharNum-1)
		local after  = sub(Lines[LineNum], CharNum) -- XXX
		Lines[LineNum] = before .. argument .. after
		message()
		return
	end
	InsertMode = true  -- to special-case display_line and charnum2colnum
	local text = {}
	local DcharsSoFar = 0
	while true do   -- the insert LOOP
		local c = getch()
--print('type(c)='.. type(c)..' c='..tostring(string.byte(c))) ; sleep(2)
		if c == "\027" then
			InsertMode = false;   constrain_char_num()
			if #text>0 then
				StoreLastChange['text'] = table.concat(text, '')
			end
			-- should do multiple inserts...
			LastWasUpOrDown = false;  LastWasLineNum = false
			display_line();  message(); return  
		elseif c == "\r" then
			if replace == 'R' then goto nextchar end
			local before   = sub(Lines[LineNum], 1, CharNum-1)
			Lines[LineNum] = sub(Lines[LineNum], CharNum)
			table.insert(Lines, LineNum, before)
			Icol = CharNum-1   -- 2.0 bugfix
			LineNum = LineNum+1; CharNum = 1; table.insert(text, '\n')
			message("line "..tostring(LineNum)..' INSERT')
			display_line()
		elseif c == KEY_LEFT then
			if CharNum > 1 then
				local oldcolnum = charnum2colnum(CharNum)
				CharNum = CharNum - 1
				local newcolnum = charnum2colnum(CharNum)
				left(oldcolnum-newcolnum)
			end
		elseif c == KEY_RIGHT then
			if CharNum < len(Lines[LineNum]) then
				local oldcolnum = charnum2colnum(CharNum)
				CharNum = CharNum + 1
				local newcolnum = charnum2colnum(CharNum)
				right(newcolnum-oldcolnum)
			end
		elseif c == KEY_DELETE then   -- even at EOL!
			if CharNum < len(Lines[LineNum]) then
				local before = sub(Lines[LineNum], 1, CharNum-1)
				local after  = sub(Lines[LineNum], CharNum+1)
				Lines[LineNum] = before .. after
				display_line()  -- this is where we needed smdc and rmdc :-(
			end
		elseif c == KEY_UP or c == KEY_DOWN then
			message('UP and DOWN are not supported in insert mode')
		elseif c == "\008" or c == "\127" then  -- \cH (even at BOL!)
--print('backspace')
			if CharNum > 1 then   -- CharNum=1 means EITHER one char, OR null
				if CharNum >= len(Lines[LineNum]) then
					Lines[LineNum] = sub(Lines[LineNum], 1, -2)
				else
					local before = sub(Lines[LineNum], 1, CharNum-2)
					local after  = sub(Lines[LineNum], CharNum)
					Lines[LineNum] = before .. after
				end
				CharNum = CharNum - 1
				display_line()  -- this is where we needed smdc and rmdc :-(
			end
		-- UP DOWN & PAGEkeys should add_to_history, but remain in InsertMode
		-- insert_mode should probably line-wrap by default...    XXX
		-- backspace in InsertMode doesn't do anything, but $Dch1 works
		-- Inserting doesn't work into a line which is already over-length
		-- should charnum2colnum take account of long lines ?
		-- XXX 20150904 with yasr, backspace, especially at EOL,
		--   must speak the deleted char, not the whole line !
		elseif c == "\t" then
			local oldcolnum = charnum2colnum(CharNum)
			local r = 0 ; if replace == 'R' then r = 1 end -- 2.1
			Lines[LineNum] = my_substr(Lines[LineNum], CharNum, r, "\t")
-- XXX linewrap ?
			CharNum = CharNum+1; table.insert(text, c)
			local newcolnum = charnum2colnum(CharNum)
			if len(expand_tabs()) >= Cols then
				-- to use $Dch1 at BOL we have to go there and then get back
				left(oldcolnum-1); puts(Dch1); right(oldcolnum-2)
			end
-- 20150914 2.1 replace mode with a tab is not so trivial...
			puts(Smir..rep(' ', newcolnum-oldcolnum)..Rmir)
		else
			local r = 0 ; if replace == 'R' then r = 1 end -- 2.1
			Lines[LineNum] = my_substr(Lines[LineNum], CharNum, r, c)
-- XXX linewrap ?
			local colnum = charnum2colnum(CharNum)  -- 1.9
			if len(expand_tabs()) >= Cols then
				left(colnum-DcharsSoFar); puts(Dch1)
				right(colnum-DcharsSoFar-1)
				DcharsSoFar = DcharsSoFar + 1
			end
			-- yasr does not speak the inserted char, but speakup does
			if replace == 'R' then puts(c) else puts(Smir..c..Rmir) end
			CharNum = CharNum + 1; table.insert(text, c)
			if Opt['keyecho'] then left(1); puts(c) end
-- Icol should be maintained by puts() etc  Icol = charnum2colnum(CharNum)
		end
		::nextchar::
	end
	warn "shouldn't reach here";
end

function split_3 (s, offset, length)
	-- if not s then s = Lines[LineNum] end
	local before = sub(s, 1, offset-1)
	local this   = sub(s, offset, offset+length-1)
	local after  = sub(s, offset+length)
	return before, this, after
end

function  do_a_tilde (multiplier)
    --local before = sub(Lines[LineNum], 1, CharNum-1)
    --local this   = sub(Lines[LineNum], CharNum, CharNum+multiplier-1)
    --local after  = sub(Lines[LineNum], CharNum+multiplier)
	local before,this,after = split_3(Lines[LineNum], CharNum, multiplier)
	local new = {}
	for i = 1, len(this) do
		local c = sub(this, i, i)
		if match(c, '[a-z]') then
			c = string.upper(c)
		elseif match(c, '[A-Z]') then
			c = string.lower(c)
		end
		new[i] = c
	end
	Lines[LineNum] = before .. table.concat(new, '') .. after
	CharNum = CharNum + multiplier
	local l = len(Lines[LineNum])
	if CharNum > l then CharNum = l end
end

function perform_a_change (a)
	-- called by the main LOOP whenever it wants to modify the file
	-- And perhaps also by colon_mode eg:  !!   !}   .,$s/old/new/g
	--   mult, eg: the 2 in 2dd
	--   range1, range2, eg: . or $ or $-5
	--   cmd,  eg: c or d or i or ! or !!
	--   pos,  eg: $ or .-6 or 2end
	--   text, eg: inserted text
	--   shellcmd, eg: fmt or 8vab
	if not a['cmd'] then
		die ("BUG: perform_a_change called without a['cmd']")
	end
	if a['cmd'] ~= '.' then
		StoreLastChange = a
	else
		if not StoreLastChange['cmd'] then
			message("no previous command to repeat"); return nil
		end
		local tmp = a['mult']
		a = StoreLastChange
	end
	add_to_history()
	FileIsChanged = true
	if not a['mult'] then a['mult'] = 1 end
	if a['cmd'] == '~' then  -- all these cases started life in the LOOP
		do_a_tilde(a['mult'])
	elseif a['cmd'] == 'J' then
		-- 20160811 it would be nice if J only spoke the remainder of the line
		local tmp = gsub(Lines[LineNum], '%s*$', '')
		for i = 1, a['mult'] do   -- but vi sees 2J as meaning join 2 lines!
			local nextline = gsub(Lines[LineNum+1], '^%s*', ' ')
			table.remove(Lines, LineNum+1)
			CharNum = len(tmp) + 1;
			tmp = tmp .. nextline
		end
		Lines[LineNum] = tmp
	elseif a['cmd'] == 'x' or a['cmd'] == KEY_DELETE then
		BufferIsWholeLine = false
		local before,this,after = split_3(Lines[LineNum], CharNum, a['mult'])
		-- local before =  sub(Lines[LineNum], 1, CharNum-1)
		-- local after  =  sub(Lines[LineNum], CharNum + a['mult'])
		-- Buffer = { sub(Lines[LineNum], CharNum, a['mult']) }
		Buffer = { this }
		Lines[LineNum] = before .. after
		constrain_char_num()
	elseif a['cmd'] == 'p' or a['cmd'] == 'P' then
		-- There are whole-line Buffers (yy, Y) and within-the-line Buffers
		--  (dw, d9w, d$)  (which can also include several lines!, eg d9w)
		if BufferIsWholeLine then
-- XXX BUG this does not get invoked for d} or y} or :.,$y etc
			CharNum = 1
			if a['cmd'] == 'p' then
				if LineNum == #Lines then
					for i,v in ipairs(Buffer) do table.insert(Lines, v) end
				else
					splice(Lines, LineNum+1, 0, Buffer)
				end
				LineNum = LineNum+1;   message()
			else   -- 'P'
				splice(Lines, LineNum, 0, Buffer)
			end
		else   -- it's a within-the-line Buffer
			if a['cmd'] == 'p' then CharNum = CharNum + 1 end
			-- BUG this handles only within-the-line Buffers containing no \n
			local before =  sub(Lines[LineNum], 1, CharNum-1)
			local after  =  sub(Lines[LineNum], CharNum)
			Lines[LineNum] = before..rep(Buffer[1],a['mult'])..after
		end
	elseif a['cmd'] == 'r' then
		local before =  sub(Lines[LineNum], 1, CharNum-1)
		local after  =  sub(Lines[LineNum], CharNum + a['mult'])
		Lines[LineNum] = before..rep(a['text'],a['mult'])..after
		CharNum = CharNum + a['mult'] ; constrain_char_num()
	elseif a['cmd'] == 'R' then   -- 2.1 Replace successive chars
		message(' REPLACE')
		insert_mode(a['text'], 'R')
	elseif a['cmd'] == 'c' then
		if a['pos'] == 'c' then  -- special-cased ergonomic change-this-line
			splice(Lines, LineNum, a{'mult'}, '')
			constrain_line_num()
			CharNum = 1
		else  -- invoke find_position and delete to there
			if ForceWholeLine[a['pos']] then CharNum = 1 end
			local end_line, endchar = find_position(a['pos'])
-- message('end_line='..tostring(end_line)..' endchar='..tostring(endchar))
-- sleep(2)
			if end_line then
				if end_line == #Lines then endchar = endchar+1 end
				delete_between(LineNum, CharNum, end_line, endchar)
				message("line "..tostring(LineNum)..' INSERT')
				insert_mode(a['text'])
			else
				message("can't find a['pos']");
			end
		end
	elseif a['cmd'] == 'd' then  -- special-cased ergonomic delete-this-line
		if a['pos'] == 'd' or a['pos'] == '$' then   -- 20200507
-- XXX not quite ... d$ should leave the empty line,
--               but dd should delete the whole line
			BufferIsWholeLine = true
			Buffer = splice(Lines, LineNum, a['mult'])
			constrain_line_num()
			CharNum = 1
		else  -- invoke find_position and delete to there
			local end_line, endchar = find_position(a['pos'])
			if end_line then
				if end_line == #Lines then endchar = endchar+1 end
				delete_between(LineNum, CharNum, end_line, endchar)
			else
				message("can't find "..tostring(a['pos']))
			end
		end
	elseif a['cmd'] == 'y' then
		if a['pos'] == 'y' then  -- special-cased ergonomic yank-this-line
			BufferIsWholeLine = true
			Buffer = {}
			for i = LineNum, LineNum+a['mult']-1 do
				Buffer[#Buffer+1] = Lines[i]
			end
			if a['mult'] > 1 then
				message(tostring(a['mult']).." lines yanked")
			end
		else  -- invoke find_position and yank to there
			local end_line, endchar = find_position(a['pos'])
			if end_line then
				if end_line == #Lines then endchar = endchar+1 end
-- NO ! BUG ! yank, not delete !
				yank_between(LineNum, CharNum, end_line, endchar)
			else
				message("can't find "..tostring(a['pos']));
			end
		end
	elseif a['cmd'] == '!' then
		if a['pos'] == '!' then
			local T, msg = io.open(TmpFile, 'w') ; if not T then
				message("can't create "..TmpFile.." "..msg)
				goto nextchange
			end
			T:write(Lines[LineNum].."\n");   T:close()
			local P, msg = io.popen(a{'shellcmd'}.." < "..TmpFile)
			if not P then
				message("can't run "..a{'shellcmd'}..": "..msg)
				goto nextchange
			end
			local answer = {}
			for line in io.lines(P) do table.insert(answer, line) end
			P:close();  os.remove(TmpFile)
			splice(Lines, LineNum, 1, answer)
		else
			if ForceWholeLine[a['pos']] then CharNum = 1 end
			local end_line, endchar = find_position(a['pos'])
			if end_line then
				local T, msg = io.open(TmpFile, 'w') ; if not T then
					message("can't create "..TmpFile.." "..msg)
					goto nextchange
				end
				local P, msg = io.popen(a['shellcmd'].." < "..TmpFile)
				if not P then
					message("can't run "..a['shellcmd']..": "..msg)
					goto nextchange
				end
				if end_line == #Lines then endchar = endchar+1 end
				local txt = delete_between(LineNum,CharNum,end_line,endchar)
				T:write(txt.."\n");   T:close()
				for line in io.lines(P) do table.insert(answer, line) end
				P:close();  os.remove(TmpFile)
				splice(Lines, LineNum, 0, answer)
			else
				message("can't find "..a['pos'])
			end
		end
	elseif a['cmd'] == 'i' then -- 20150905
		message("line "..tostring(LineNum)..' INSERT')
		insert_mode(a['text'])
	elseif a['cmd'] == 'I' then
		CharNum=1; display_line()
		message("line "..tostring(LineNum)..' INSERT')
		insert_mode(a['text'])
	elseif a['cmd'] == 'a' then
		CharNum = CharNum+1; display_line()  -- already-at-EOL is special..
		if CharNum > len(Lines[LineNum]) then right(1)
		else  message("line "..tostring(LineNum)..' INSERT')
		end
		insert_mode(a['text'])
	elseif a['cmd'] == 'A' then
		CharNum = 1 + len(Lines[LineNum])
		display_line(); right(1)
		insert_mode(a['text'])   -- mustn't call message if after EOL
	elseif a['cmd'] == 'C' then
		Lines[LineNum] = sub(Lines[LineNum], 1, CharNum-1)  -- XXX -1 ?
		clrtoeol(); insert_mode(a['text'])   -- no message if after EOL
	elseif a['cmd'] == 'D' then
		BufferIsWholeLine = false
		local before =  sub(Lines[LineNum], 1, CharNum-1)
		local after  =  sub(Lines[LineNum], CharNum)
		Lines[LineNum] = before
		Buffer = { after }
	elseif a['cmd'] == 'O' then   -- open a new line above
		CharNum = 1
		table.insert(Lines, LineNum, '');   display_line()
		message("line "..tostring(LineNum)..' INSERT')
		insert_mode(a['text'])
	elseif a['cmd'] == 'o' then   -- open a new line below
		LineNum = LineNum+1; CharNum = 1
		table.insert(Lines, LineNum, '');   display_line()
		message("line "..tostring(LineNum)..' INSERT')
		insert_mode(a['text'])
	end
	display_line()
	::nextchange::
end

function find_dialogue (c)   -- no multipliers here, please
	-- need to separate finding from pre-dialogue and post-display. So:
	if     c == '/' then FindForwards   = 1;  find_forwards = 1
	elseif c == '?' then FindForwards   = -1; find_forwards = -1
	else message("BUG: find_dialogue called with c="..c); return
	end
	local find_string = read_line(c)
	if find_string == '' then display_line(); return end
	local s, msg = pcall(function ()
		return match('abcd', find_string)
	end)
	if not s then  -- avoid dieing on RE syntax errors
		message (msg); return
	end
	FindString = find_string
	local line_num, char_num = find_position('n')
	if char_num then
		LineNum = line_num; CharNum = char_num
		LastWasUpOrDown = false
		message()
		display_line()
	else message(find_string.." not found")
	end
end

function endpos_dialogue (cmd)   -- eg: 'c' or 'd' or '!'
	-- the $pos (eg: d5w) ends on } w b e ^ $ '[a-z] /astring\n ?astr\n
	-- /astring/+4   many,many possibilities... (also from c,!,y)
	local pos = {}
	while true do
		local c = getch()
		if c == "\027" then return nil end
		if c == 'w' or c == 'b' or c == 'e' or c == '}' or c == '{'
		  or c == '^' or c == '$' or c == cmd then
			table.insert(pos, c) ;   break
		end
-- XXX must handle d$ as delete-to-EOL (not to delete-to-last-line) !
--     likewise y$ and c$ and !$
--     in other words '$' AS THE FIRST GETCH() must be special-cased
		if match(c, '%d') then
			table.insert(pos, c);  goto nextdialogue
		end
		if c == "'" then
			table.insert(pos, "'")
			local c = getch()
			if c == "\027" then return nil
			elseif match(c, '[a-z]') then
				table.insert(pos, c) ;   break
			else message("strange mark '"..c);  return nil
			end
		end
		if c == '/' or c == '?' then
			table.insert(pos, c)
			table.insert(pos, read_line(c))
		end
		message("strange position "..c)
		::nextdialogue::
	end
	-- local $p = join '',@pos; debug("p=$p");
	return table.concat(pos, '')
end

function seek_in_line (delta, c)   -- used by f F ; ,
	local line = Lines[LineNum]
	local seekchar
	if c then seekchar=c; LastSeekChar=c else seekchar=LastSeekChar end
	if not seekchar then message('no previous seek') ; return end
	local char_num = CharNum + delta
	while char_num >= 1 and char_num <= len(line) do
		local c = sub(line, char_num, char_num)
		if c == seekchar then CharNum = char_num break end
		char_num = char_num + delta
	end
	message(format("character %d", CharNum))
	return
end

function chomp (a)
	for i = 1, #a do a[i] = string.gsub(a[i], '[\r\n]$', '') end
end

function re_do ()   -- 20130718 still just single-level, like Sun vi
	local tmp = table.concat(Lines,"\n").."\n"
	Lines = split("\n", HistoryMostRecent);  chomp(Lines)
	HistoryMostRecent = tmp
	LineNum = HistoryLineNums[1]  -- restore LineNum
	CharNum = HistoryCharNums[1]  -- restore CharNum
	message(); display_line()
end
function un_do ()   -- 20130718 still just single-level, like Sun vi
	local tmp = table.concat(Lines, "\n").."\n"
	Lines = split(HistoryMostRecent, "\n");  chomp(Lines)
	HistoryMostRecent = tmp
	LineNum = HistoryLineNums[1]  -- restore LineNum
	CharNum = HistoryCharNums[1]  -- restore CharNum
	message(); display_line()
end

function word_under_cursor ()
	local line = Lines[LineNum];
	local this   = substr(line, CharNum, 1)
	if not match(this, '%w') then return nil end
	local before = substr(line, 1, CharNum)
	local after  = substr(line, CharNum+1)
	before = match(before, '(%w*)$')
	after  = match(after, '^(%w*')
	return before..this..after
end

function command_mode ()
	-- command_mode handles (\d+) h j k l u ^R m ' ~ x r b w p d.* c.*
	--  and after  : / ? i I o O  it invokes another mode.
	-- we separate insert_mode, replace_mode from here
	-- in command, insert and replace modes we are at a particular
	--  LineNum and CharNum, and can move around with the arrow-keys
	-- therefore these movements are handled by sub movement
	local multiplier = 0
	display_line()
	while true do   -- the main LOOP
		local c = getch()
-- print ('c = '..c..'  '..type(c)) ; sleep(1)
		if match(c, '^%d$') then
			if multiplier == 0 and c == '0' then   -- BOL
--print('B O L')
				CharNum=1; display_line()
				goto nextcommand
			end
			multiplier = 10*multiplier + tonumber(c)
			goto nextcommand
-- XXX this conflicts with ',' meaning seek_in_line in the other direction
--		elseif ($c == ',') { next;  -- specifies ranges, eg:  .,$d  2,30y
		end
		if multiplier < 1 then multiplier = 1 end
		LastWasUpOrDown = false
		if c == '/' or c == '?' then find_dialogue(c);
		elseif c == 'n' or c == 'N'
		  or c == 'w' or c == 'b' or c == 'e' then  -- with multiplier
			local line_num,char_num=find_position(tostring(multiplier)..c);
			if char_num then
				LineNum = line_num; CharNum = char_num
				message()
				display_line()
			else message("not found")
			end
		elseif c == ':' then
-- print('about to call colon_mode()')
			if 'next' == colon_mode() then return 'next' end
			CharNum = 1
			display_line()
		elseif c == '#' then
			local word = word_under_cursor();
			if word then
				FindString     = word;
				FindForwards   = -1
				local line_num, char_num = find_position('n')
				if char_num then
					LineNum = line_num; CharNum = char_num
					LastWasUpOrDown = false
					message()
					display_line()
				else message(find_string.." not found")
				end
			else
				message("no word under cursor");
			end
		elseif c == 'f' then
			SeekForwards = 1;  seek_in_line( 1, getch())
			display_line()
		elseif c == 'F' then
			SeekForwards = -1; seek_in_line(-1, getch())
			display_line()
		elseif c == ';' then
			seek_in_line(SeekForwards)
			display_line()
		elseif c == ',' then
-- BUG this inverts SeekForwards EVERY time it's pressed :(
-- I think seek_in_line() needs an extra argument !
			seek_in_line(-1*SeekForwards)
			display_line()
		elseif c == 'g' or c == KEY_HOME then
			LineNum = 1;  CharNum = 1
			message(); display_line()
		elseif c == 'G' or c == KEY_END then
			LineNum = #Lines;  CharNum = len(Lines[LineNum])
			constrain_char_num()
			message(); display_line()
		elseif c == KEY_LEFT or c == 'h' or c == "\008" or c == "\127" then
			if CharNum <= 1 then message("already at B O L"); CharNum = 1
			else
				CharNum = CharNum - multiplier;
				if CharNum < 1 then CharNum = 1 end
				display_line()
				message()
			end
		elseif c == KEY_DOWN or c == 'j' or c == "\r" then
			if LineNum >= #Lines then
				message("already at E O F"); goto nextcommand
			end
			LineNum = LineNum + multiplier
			constrain_line_num()
			if c == "\r" then CharNum = 1 end
--message("down LineNum = "..tostring(LineNum)) ; sleep(1)
			local l = len(Lines[LineNum]) -- ARGHH can be -1 !!
			if l >= 1 and (CharNum > l) then CharNum = l end
			LastWasUpOrDown = true
			message();  display_line()
		elseif c == KEY_UP or c == 'k' then
			if LineNum <= 1 then
				message("already at B O F") goto nextcommand
			end
			LineNum = LineNum - multiplier
			if LineNum < 1 then LineNum = 1 end
--message(" up  LineNum = "..tostring(LineNum)) ; sleep(1)
			local l = len(Lines[LineNum])
			if l >= 1 and CharNum > l then CharNum = l end
			LastWasUpOrDown = true
			message(); display_line()
		elseif c == KEY_RIGHT or c == 'l' then
-- print('right CharNum='..tostring(CharNum))
			local l = len(Lines[LineNum])
			if CharNum >= l then message("already at E O L")
			else
				CharNum = CharNum + multiplier
				local l = len(Lines[LineNum])
				if CharNum > l then CharNum = l end
				display_line()
				message()
			end
		elseif c == '$' then   -- to end of line
			CharNum = len(Lines[LineNum])
			display_line()
		elseif c == KEY_NPAGE then
			LineNum = LineNum + LinesPerPage;   constrain_line_num()
			if CharNum > len(Lines[LineNum]) then
				CharNum = len(Lines[LineNum])
				constrain_char_num()
			end
			message(); display_line()
		elseif c == KEY_PPAGE then
			LineNum = LineNum - LinesPerPage;   constrain_line_num()
			if CharNum > len(Lines[LineNum]) then
				CharNum = len(Lines[LineNum])
				constrain_char_num()
			end
			message(); display_line()
		elseif c == '~' or c == 'x' or c == KEY_DELETE
		  or c == 'J' or c == '.' or c == 'p' or c == 'P' or c == 'R'
		  or c == 'i' or c == 'I' or c == 'o' or c == 'O' or c == 'a' then
			perform_a_change( {mult=multiplier, cmd=c} )
		elseif c == 'C' or c == 'D' or c == 'A' then
			perform_a_change( {cmd=c} )
		elseif c == '=' then
			local s = format("line %d out of %d, char %d, file ",
			  LineNum+1,  #Lines,  CharNum)
			if FileIsChanged then s=s..'is changed' else s=s..'unchanged' end
			message(s)
		elseif c == 'r' then  -- replace one char
			local c2 = getch();   if c2 == "\027" then goto nextcommand end
			perform_a_change( {mult=multiplier, cmd=c, text=c2} );
		elseif c == 'c' or c == 'd' or c == 'y' then
			local pos = endpos_dialogue(c);  -- passes c to detect dd
			perform_a_change( {mult=multiplier, cmd=c, pos=pos} );
		elseif c == '!' then
			local c2 = getch();   if c2 == "\027" then goto nextcommand end
			-- must loop to collect a possible sub-multiplier, eg: !5end
			local shellcmd = read_line('!');
			if not shellcmd then goto nextcommand end
			perform_a_change( {mult=multiplier, cmd=c,
			  pos=c2, shellcmd=shellcmd} )
		elseif c == 'Y' then   -- same as yy
			perform_a_change( {mult=multiplier, cmd='y', pos='y'} )
		elseif c == 'Z' then
			local c2 = getch();  if c2 == 'Z' then
-- for i,v in ipairs(Lines) do print(v) end
				save_dialogue(nil,'quitting'); quit_dialogue()
			end
		elseif c == 'm' then  -- set mark
			local c2 = getch();  if match(c2, '[a-zA-Z]') then
				Mark2LineNum[c2] = LineNum
				Mark2CharNum[c2] = CharNum
				message("mark "..c2.." set")
			end
		elseif c == "'" then  -- goto a mark
			local c2 = getch();  if match(c2, '[a-zA-Z]') then
				goto_position("'"..c2, "mark "..c2.." not set")
			end
		elseif c == '{' or c == '}' then  -- previous or next paragraph
			goto_position(multiplier..c, "no more paragraphs")
		elseif c == 'u'    then un_do()
		elseif c == "\022" then re_do()
		elseif c == "\027" then goto nextcommand -- should flash
		end
		multiplier = 0
		::nextcommand::
	end
end
------------------------------------------------------ 

Cols, Rows,Xpix,Ypix = RK.GetTerminalSize();
--[[
	SIGWINCH is shown in kill -l but is not known to luaposix
	SIG{'WINCH'} = sub {
	(Cols, Rows,Xpix,Ypix) = Term::ReadKey::GetTerminalSize();
	};
]]
-- print(Cols, Rows,Xpix,Ypix) -- ; os.exit(0)

-- pinched from Term::Clui
initscr()
gotoxy(0, DisplayLine+2)
-- function END { print "\r\n"; endwin(); }   MUST DO THIS EXPLICITLY !


if #arg > IARG+1 then
	message(format("%d files to edit", #arg-IARG))
	sleep(1)
end
for i = IARG, #arg do   -- LOOP over files
	FileName = arg[i]
	-- print('FileName =',FileName)
	FileLastSaved = os.time()
	LineNum = tonumber(get_default(FileName)) or 1
	CharNum = 1 ; Icol=0
	local msg = "line "..LineNum
	if is_directory(FileName)  then
		if i < #arg then
			message(format("%s is a directory, skipping", FileName))
			sleep(2); goto nextfile
		else
			up(2); warn(format("sorry, %s is a directory\n", FileName));
			up(1); exit(1)
		end
	end
	-- print('exists(FileName) =',exists(FileName))
	if not exists(FileName) then
		msg = " new file";
		F,m = io.open(FileName, 'w')
		if not F then
			warn("can't create %s: %s\r\n", FileName,m); goto nextfile
		else
			F:close()
		end
		os.remove(FileName)   -- q! should leave no file
	else
		if not is_writeable(FileName) then
			msg = " warning: editing a read-only file"; end
		F,msg = io.open(FileName, 'r')
		if not F then
			warn(format("can't write to %s: %s\r\n", FileName,msg));
			goto nextfile
		end
		F:close()
-- print ('io.lines('..FileName..')')
		for line in io.lines(FileName) do Lines[#Lines+1] = line end
	end
	if #Lines == 0 then Lines = {''} end
	constrain_line_num()
	FileIsChanged = false
	-- Modes: command, insert, replace, colon, find
	if MinusC then colon_mode(MinusC) end   -- should be a list
	display_line()
	message(msg)
	command_mode() -- every other mode returns to command_mode
	::nextfile::
end  -- end of LOOP over files
exit(1)  -- the normal exit is through colon_mode

--[=[

=pod

=head1 NAME

vibe - a vi-like line-editor designed to work with I<yasr> or I<speakup>

=head1 SYNOPSIS

 vibe filename
 vibe -c '$' ~/log/thoughts
 vibe -v        # prints the version
 perldoc vibe   # read the manual :-)

=head1 DESCRIPTION

This script is a line-based editor written, in I<Perl> and in I<Lua>,
to work well with I<speakup> or with I<yasr>,
and to be easy to learn for people familiar with I<vi>.
It is mostly keystroke-compatible with I<vi>.
It currently handles:

 h j k l 5j ArrowKeys PageUp/Down { } 0 $ w b e :123 :1 Home :$
 End /somestring /perlregexp[a-m]?\d+.txt$ J i I x p P dd d} c C D
 !!fmt !}fmt dw d5w yw yy y} u Ctrl-R ZZ :w :n :q :wq

and many combinations of the above, like B<.,$d>

=head1 DIFFERENCES

Unlike I<vi>, B<cw> is not special-cased to mean B<ce>,
find with B</> or B<?> do not loop through the file,
B<=> is introduced to mean display-where-we-are

vibe is currently in its early versions.
Currently, the "u" undo-command only stores one level of history
(like the old I<Sun> vi did).

=head1 OPTIONS

=over 3

=item I<-c {command}>

{command} will be executed as an Ex command
after the first file has been read.
If the {command} contains spaces it must be enclosed in quotes.
Note: Unlike in I<vim>, you can only use one "-c" command.
Examples:

 prompt> vibe -c '$' ~/log/events
 prompt> grep veb ~/.bashrc
 alias veb="/usr/local/bin/vibe -c '$'"

=item I<-v>

Prints version number.

=back

=head1 CONFIGURATION

So far, I<vibe> does not have its own configuration file.
It does consult the I<~/.vimrc> to extract the I<tabstop> line:
 set tabstop=4

( it could conceivably also use wrap and keyecho ... )

but its other configurables are set by environment variables:

=over 3

=item I<VIBE_READER>

Although I<vibe> works satisfactorily under both I<yasr> and I<speakup>,
it can optimise its speaking behaviour slightly
according to the screen-reader being used.
The difference is small, because the screen-reader is not necessarily 
on the same host as I<vibe>, so I<vibe> is not able to use
I</sys/accessibility/speakup/> or I</proc/speakup/> to achieve any
fine-grained control.
But still, set I<export VIBE_READER=speakup> if you are using I<speakup>.
The default is I<yasr>.

=item I<VIBE_KEYECHO>

If this variable is set, I<vibe> in insert mode will attempt to speak
each character as it is inserted.

=item I<CLUI_DIR>

This variable is shared with the I<Term::Clui> CPAN module.
The database $ENV{CLUI_DIR}/vibe or ~/.clui_dir/vibe is
used to remember the current line number between invocations.
This mechanism can be disabled by setting CLUI_DIR=OFF if you really want to.

=back

=head1 CHANGES

 20200510  2.4 f F ; and , now work
 20200508  2.3 fix crash if !}fmt swallows the whole file
 20200507  2.2 fix d$, and { to BOF, and } or d} to EOF
 20150914  2.1 'R' = REPLACE though tabs not well-handled yet
 20150910  2.0 introduce -R readonly; puts_xy_clr reduces race conditions 
 20150905  1.9 $LastWasUpOrDown reduces verbosity under yasr, :r works
 20130801  1.8 ce and yy work, . repeats inserts, yyp and yyP work
 20130731  1.7 bug fixes in insert; saves line-number between invocations
 20130730  1.6 delete_between and thence dw d5w d} !} 
 20130728  1.5 insert_mode, C o and O; approaching releasability
 20130724  1.4 factor perform_a_change out of the main LOOP
 20130715  1.3 separate find_position, handles also \d+, $, .+5 etc
 20130525  1.2 tab expansion seems to work
 20130524  1.1 command_mode up to proof-of-concept stage
 20130331  1.0 first version

=head1 AUTHOR

Peter J Billam   http://www.pjb.com.au/comp/contact.html

=head1 CREDITS

Based on I<vi>, I<yasr> and I<speakup>

=head1 SEE ALSO

 http://search.cpan.org/perdoc?Diff::LibXDiff
 or, a lot easier to install:
 http://search.cpan.org/perdoc?Text::Diff
 http://search.cpan.org/perdoc?Algorithm::Diff
 http://search.cpan.org/perdoc?Text::Patch

 http://search.cpan.org/perdoc?Term::ReadKey
 http://www.pjb.com.au/
 perl(1).

=cut

]=]
